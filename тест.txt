Никак не получается вставить чекбокс в создаваемый контейнер:



/**
 * Создает переключатель чекбокса с уникальным именем.
 * @param {string} checkboxId - Уникальный идентификатор чекбокса.
 * @param {boolean} defaultValue - Значение по умолчанию (true - включен, false - выключен).
 */
function createCheckboxToggle(checkboxId, defaultValue) {
    // Создаем элементы чекбокса
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = checkboxId; // Устанавливаем id чекбокса
    checkbox.name = checkboxId; // Устанавливаем уникальное имя чекбокса
    checkbox.checked = defaultValue;
    
    // Добавляем классы для стилизации (будут определены в CSS)
    checkbox.classList.add('toggle-checkbox');
    
    // Добавляем обработчик события изменения состояния чекбокса
    checkbox.addEventListener('change', function() {
        // Здесь можно добавить логику, которая сработает при изменении состояния
        console.log(`Чекбокс ${checkboxId} изменен: ${checkbox.checked}`);
    });
    
    // Создаем контейнер для чекбокса и добавляем его на страницу (предположим, что есть контейнер с id 'checkbox-container')
    const container = document.getElementById('checkbox-container');
    container.appendChild(checkbox);
}





/**
 * Создает контейнер с заголовком, содержащий инпут для умного ввода числовых значений,
 * используя данные из JSON файла.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 */
function createContainerWithInput(id, type, number, gender, age, parentContainer) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    // Загружаем данные из JSON файла
    fetch('data.json')
        .then(response => response.json())
        .then(data => {
            // Определяем заголовок контейнера в зависимости от типа и номера
            let headerText = 'Unknown Type';

            if (data[type] && data[type][number.toString()]) {
                headerText = data[type][number.toString()];
            }

            // Проверяем количество уже существующих контейнеров с данным типом
            const existingContainers = parentContainer.querySelectorAll(`.inputContainer[data-type="${type}"]`);
            const containerCount = existingContainers.length + 1;

            // Вставляем заголовок в начало контейнера
            container.textContent = `${containerCount}. ${headerText}`;
            container.setAttribute('data-type', type); // Добавляем атрибут для удобства подсчета

            

            // Создаем переключатель чекбокса с идентификатором "checkbox-container" и значением по умолчанию false
    createCheckboxToggle(id, false);
            

            // Создаем выпадающий список перед инпутом
            createDropdownList(`${id}-dropdown`, headerText, container, gender, age).then(() => {
                // Создаем инпут с помощью функции createSmartInput, передав ID контейнера
                createSmartInput(`${id}-input`, 10, 6, id); // Пример использования createSmartInput с генерацией уникального ID для инпута
            });

            // Добавляем контейнер в родительский контейнер
            parentContainer.appendChild(container);
        })
        .catch(error => {
            console.error('Error fetching data:', error);
        });
}


















/**
 * Создает контейнер с заголовком, содержащий инпут для умного ввода числовых значений,
 * используя данные из JSON файла.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 */
function createContainerWithInput(id, type, number, gender, age, parentContainer) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    // Загружаем данные из JSON файла
    fetch('data.json')
        .then(response => response.json())
        .then(data => {
            // Определяем заголовок контейнера в зависимости от типа и номера
            let headerText = 'Unknown Type';

            if (data[type] && data[type][number.toString()]) {
                headerText = data[type][number.toString()];
            }

            // Проверяем количество уже существующих контейнеров с данным типом
            const existingContainers = parentContainer.querySelectorAll(`.inputContainer[data-type="${type}"]`);
            const containerCount = existingContainers.length + 1;

            // Вставляем заголовок в начало контейнера
            container.textContent = `${containerCount}. ${headerText}`;
            container.setAttribute('data-type', type); // Добавляем атрибут для удобства подсчета

            

            

        // Вызываем createCheckboxToggle и обрабатываем промисы
createCheckboxToggle(id, true)
.then(() => {
    console.log('Чекбокс успешно создан и добавлен.');
    // Дополнительный код после успешного создания чекбокса
})
.catch(error => {
    console.error('Ошибка при создании чекбокса:', error);
});

            

            // Создаем выпадающий список перед инпутом
            createDropdownList(`${id}-dropdown`, headerText, container, gender, age).then(() => {
                // Создаем инпут с помощью функции createSmartInput, передав ID контейнера
                createSmartInput(`${id}-input`, 10, 6, id); // Пример использования createSmartInput с генерацией уникального ID для инпута
            });

            // Добавляем контейнер в родительский контейнер
            parentContainer.appendChild(container);
        })
        .catch(error => {
            console.error('Error fetching data:', error);
        });
}






Смотри у нас есть глобальная переменная которая хранит все состояния чекбоксов. И у нас есть умный инпут. Можно ли улучшить функцию умного
инпута таким образом, чтобы при включенном чекбоксе который находится в том же родительском контейнере, что и инпут - инпут блокировался и в него ничего нельзя было бы ввводить?
Вот код:


// Глобальный объект для хранения состояний чекбоксов
const checkboxStates = {};

/**
 * Асинхронно создает переключатель чекбокса.
 * @param {string} id - Идентификатор элемента, куда будет вставлен чекбокс.
 * @param {boolean} defaultValue - Значение по умолчанию (true - включен, false - выключен).
 */
async function createCheckboxToggle(id, defaultValue) {
    try {
        // Находим элемент, куда нужно вставить переключатель
        const container = document.getElementById(id);
        
        // Создаем элементы чекбокса
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = defaultValue;
        
        // Устанавливаем начальное значение в глобальном объекте
        checkboxStates[id] = defaultValue;

        // Добавляем классы для стилизации (будут определены в CSS)
        checkbox.classList.add('toggle-checkbox');
        
        // Устанавливаем стиль для смещения чекбокса на 550 пикселей влево
        checkbox.style.position = 'absolute';
        checkbox.style.left = '100px';
        checkbox.style.border = '1px solid rgba(78, 78, 78, 0.25)';
        checkbox.style.borderRadius = '20px';
        
        // Добавляем обработчик события изменения состояния чекбокса
        checkbox.addEventListener('change', function() {
            if (checkbox.checked) {
                checkbox.style.backgroundColor = '#c295343f';
                checkbox.style.borderColor = 'rgba(78, 78, 78, 0.25)';
            } else {
                checkbox.style.backgroundColor = 'white';
                checkbox.style.borderColor = 'rgba(78, 78, 78, 0.25)';
            }
            // Обновляем значение в глобальном объекте
            checkboxStates[id] = checkbox.checked;
            console.log(`Чекбокс ${id} изменен: ${checkbox.checked}`);
        });
        
        // Добавляем чекбокс в контейнер
        container.appendChild(checkbox);
    } catch (error) {
        console.error('Error creating checkbox:', error);
    }
}


/**
 * Создает инпут для умного ввода числовых значений с заданными ограничениями.
 * @param {string} id - ID элемента, к которому будет привязан инпут.
 * @param {number} maxLength - Максимальная длина всего числового значения.
 * @param {number} maxDecimalLength - Максимальная длина дробной части числового значения.
 * @param {string} containerId - ID контейнера, в который нужно добавить инпут.
 */
function createSmartInput(id, maxLength, maxDecimalLength, containerId) {
    const container = document.getElementById(containerId);

    

    const label = document.createElement('label');
    label.setAttribute('for', id);
    label.textContent = '';

    const input = document.createElement('input');
    input.type = 'text';
    input.id = id;

    const status = document.createElement('div');
    status.id = `${id}-status`;
    status.classList.add('status');

    container.appendChild(label);
    container.appendChild(input);
    container.appendChild(status);

    // Создаем индикатор и добавляем его в контейнер
    createIndicator(input.value.trim() !== '', container);

    // Функция для проверки значения и обновления статуса индикатора
    function updateIndicatorStatus(value) {
        createIndicator(value.trim() !== '', container);
    }

    // Переменные для хранения состояния
    let originalValue = ''; // Переменная для хранения оригинального значения перед редактированием
    let pasteEventTriggered = false; // Флаг для отслеживания вставки

    

    input.addEventListener('input', function() {
        if (pasteEventTriggered) {
            pasteEventTriggered = false;
            return;
        }
    
        let value = this.value.trim(); // Убираем начальные и конечные пробелы
        let firstChar = value.charAt(0);
    
        // Заменяем запятую на точку
        value = value.replace(',', '.');
    
        // Проверяем первый символ и сохраняем его, если это > или <
        if (firstChar === '>' || firstChar === '<') {
            value = firstChar + value.slice(1).replace(/[^\d.]/g, '');
        } else {
            value = value.replace(/[^\d.]/g, '');
        }
    
        // Ограничение на максимальную длину числового значения
        if (maxLength && value.length > maxLength) {
            value = value.slice(0, maxLength);
        }
    
        // Ограничение на максимальную длину дробной части
        if (maxDecimalLength && value.includes('.')) {
            let parts = value.split('.');
            parts[0] = parts[0].slice(0, maxLength); // Ограничение целой части
            parts[1] = parts[1].slice(0, maxDecimalLength); // Ограничение дробной части
            value = parts.join('.');
        }
    
        // Сохраняем текущее значение перед очисткой
        originalValue = value;
    
        // Устанавливаем очищенное значение обратно в инпут
        this.value = value;

        
    
        // Проверка значения и обновление статуса
        updateGradePanelStatus(this.value, containerId);

        // После обновления значения вызываем функцию для обновления индикатора
        updateIndicatorStatus(this.value);
        
    
        // Задержка перед проверкой и очисткой дробной части
        setTimeout(() => {
            let currentValue = this.value;
    
            // Удаляем дробную часть, если в ней только нули
            if (/^\d+\.[0]+$/.test(currentValue)) {
                currentValue = currentValue.split('.')[0];
                this.value = currentValue;
                updateGradePanelStatus(this.value, containerId); // Обновление статуса после изменения значения
                // После обновления значения вызываем функцию для обновления индикатора
                updateIndicatorStatus(this.value);
            }
        }, 5000); // Задержка 5 секунды
    });
    

    // Обработка вставки из буфера обмена
    input.addEventListener('paste', function(event) {
        event.preventDefault();
        let pasteText = (event.clipboardData || window.clipboardData).getData('text');
        pasteText = pasteText.trim(); // Убираем начальные и конечные пробелы
        let firstChar = pasteText.charAt(0);

        // Заменяем запятую на точку
        pasteText = pasteText.replace(',', '.');

        // Проверяем первый символ и сохраняем его, если это > или <
        if (firstChar === '>' || firstChar === '<') {
            pasteText = firstChar + pasteText.slice(1).replace(/[^\d.]/g, '');
        } else {
            pasteText = pasteText.replace(/[^\d.]/g, '');
        }

        // Убираем нули в конце дробной части (если есть)
    if (pasteText.includes('.')) {
        pasteText = pasteText.replace(/(\.[0-9]*[1-9])0+$/, '$1');

        // Удаляем дробную часть, если в ней только нули
        if (/^\d+\.[0]+$/.test(pasteText)) {
            pasteText = pasteText.split('.')[0];
        }
    }

        // Устанавливаем очищенный текст обратно в инпут
        document.execCommand('insertText', false, pasteText);

        pasteEventTriggered = true; // Устанавливаем флаг вставки
    });

    // Обработка события потери фокуса (blur)
    input.addEventListener('blur', function() {
        // Если событие вставки не происходило
        if (!pasteEventTriggered) {
            // При потере фокуса, убираем нули в конце дробной части (если есть)
            if (this.value.includes('.')) {
                let trimmedValue = originalValue.replace(/(\.[0-9]*[1-9])0+$/, '$1');
                this.value = trimmedValue;
            }
        }
        pasteEventTriggered = false; // Сбрасываем флаг вставки
    });
}



labSelect.style.backgroundColor = 'white';
            labSelect.style.border = `2px solid #dddddd`;
            labSelect.style.borderRadius = `20px`;




            // Создаем выпадающий список для выбора лаборатории
            const labSelect = createSelect('lab-select', 'Выберите лабораторию', data.map(lab => ({
                value: lab.id,
                text: lab.name
            })));
            panel.appendChild(labSelect);





            смотри, мы берем данные из normal_positions.json для наполнения выпадающего списка, я добавил туда в каждый блок
            2 новых параметра, это lab и panel. Начнем с простого, ты можешь не показывать параметры в выпадающем списке, если
            значение lab в них не совпадает со значением lab из глобальной переменной laboratory  (она объявлена в другой части проекта)?
            Дополни код.

/**
 * Создает выпадающий список с элементами, извлечёнными из JSON файла.
 * @param {string} id - ID выпадающего списка.
 * @param {string} filterName - Имя для фильтрации позиций в JSON файле.
 * @param {HTMLElement} container - Контейнер, в который будет добавлен выпадающий список.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @returns {Promise<void>} - Возвращает промис для синхронизации с другими действиями.
 */
async function createDropdownList(id, filterName, container, gender, age) {
    let isOpen = false; // Флаг для отслеживания состояния открытия списка
    const select = document.createElement('select');
    const searchInput = document.createElement('input');
    let selectedOption = null; // Выбранная опция

    

    try {
        select.id = id;
        const response = await fetch('normal_positions.json');
        const data = await response.json();

        // Фильтруем данные по названию и полу
        const filteredPositions = data.positions.filter(position => {
            return position.name === filterName && position.gender === gender;
        });

        select.addEventListener('change', () => {
            const inputValue = document.getElementById(`${container.id}-input`).value;
            updateGradePanelStatus(inputValue, container.id);


            // Сбрасываем стиль предыдущей выбранной опции
            if (selectedOption) {
                selectedOption.style.color = 'black'; // Синий цвет для не выбранной опции
            }
        
            // Получаем выбранную опцию
            selectedOption = select.options[select.selectedIndex];
            selectedOption.style.color = 'blue'; // Синий цвет для выбранной опции
        
            // Получаем значения границ из выбранной опции
            const bounds = JSON.parse(selectedOption.value);
            
            
        });

        
        


        // Функция для создания опции в списке
        const createOption = (position) => {
            const option = document.createElement('option');
            option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });
        
            // Создаем структуру из span элементов для разных частей текста
            const nameSpan = document.createElement('span');
            nameSpan.textContent = `${position.name} ${position.lowerBound} - ${position.upperBound} ${position.unit} `;
            option.appendChild(nameSpan);
        
            const ageSpan = document.createElement('span');
            ageSpan.textContent = `[Возраст: ${position.ageLowerBound}-${position.ageUpperBound}]`;
            ageSpan.classList.add('gray-text'); // Добавляем класс для серого цвета
            option.appendChild(ageSpan);
        
            if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
                option.classList.add('matched-option');
            }
        
            select.appendChild(option);
        
            // Проверяем, соответствует ли текущая опция всем условиям фильтрации
            if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
                selectedOption = option;
            }
        };
        


        // Функция для фильтрации поискового запроса
        const filterOptions = (searchTerm) => {
            const lowerCaseSearch = searchTerm.toLowerCase();
            select.innerHTML = ''; // Очищаем список перед добавлением отфильтрованных элементов

            filteredPositions.forEach(position => {
                // Преобразуем диапазон в строку для поиска
                const rangeString = `${position.lowerBound}-${position.upperBound}`;

                // Проверяем, содержится ли поисковый запрос в названии, единице измерения или диапазоне
                if (position.name.toLowerCase().includes(lowerCaseSearch) ||
                    position.unit.toLowerCase().includes(lowerCaseSearch) ||
                    rangeString.includes(lowerCaseSearch)) {
                    createOption(position);
                }
            });

            // Показываем или скрываем инпут для поиска в зависимости от наличия отфильтрованных элементов
            if (select.options.length > 0) {
                searchInput.style.display = 'block';
            } else {
                searchInput.style.display = 'none';
            }
        };

        // Инициализация инпута для поиска
        searchInput.type = 'text';
        searchInput.placeholder = 'Поис ...';
        searchInput.classList.add('search-input'); // Добавляем класс для стилей
        searchInput.style.display = 'none'; // Начинаем с скрытым инпутом
        searchInput.addEventListener('input', () => {
            filterOptions(searchInput.value.trim());
        });
        container.appendChild(searchInput);

        // Добавляем выпадающий список в контейнер
        container.appendChild(select);

        // Обработчик клика по выпадающему списку для открытия/закрытия инпута поиска
        select.addEventListener('click', (event) => {
            event.stopPropagation(); // Остановка всплытия события, чтобы клик по select не срабатывал на документе
            isOpen = !isOpen;
            if (isOpen) {
                searchInput.style.display = 'block';
            } else {
                searchInput.style.display = 'none';
            }
        });

        // Добавляем обработчик изменения для обновления стиля
        select.addEventListener('change', () => {
            if (selectedOption && selectedOption.classList.contains('matched-option')) {
                select.classList.add('matched-select');
                
            } else {
                select.classList.remove('matched-select');
                
            }
        });

        // Инициализируем выпадающий список с текущими фильтрованными данными
        filteredPositions.forEach(createOption);

        

        // Если найдена соответствующая опция при загрузке, делаем её выбранной
        if (selectedOption) {
            selectedOption.selected = true;
        }

        // Обработчик клика на документе для закрытия инпута, если кликнуто вне контейнера
        document.addEventListener('click', (event) => {
            const isClickedInside = container.contains(event.target);
            if (!isClickedInside) {
                isOpen = false;
                searchInput.style.display = 'none';
                
            }
        });

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}




Помоги улучшить код ниже. Нужно добавить еще один входной аргумент, это tarif. Еще смотри, джейсон файл, который
мы читаем по нормал позишенс, там теперь такая структура у каждого объекта:

{
            "name": "Натрий",
            "lowerBound": 210,
            "upperBound": 950,
            "unit": "пг/мл",
            "gender": "male",
            "ageLowerBound": 50,
            "ageUpperBound": 65,
            "lab": "Хромолаб",
            "panel": "1"
        },

        На lab не обращай внимание, а вот panel мы теперь будем проверять. Смотри, по аналогии с полом мы не будем
        показывать в выпадающем списке параметры, которые не совпадают по панели. А новый входной аргумент, значение из
        него мы как раз будем получать глобальный номер текущей панели.



А вот самая функция, которую нужно улучшить

/**
 * Создает выпадающий список с элементами, извлечёнными из JSON файла.
 * @param {string} id - ID выпадающего списка.
 * @param {string} filterName - Имя для фильтрации позиций в JSON файле.
 * @param {HTMLElement} container - Контейнер, в который будет добавлен выпадающий список.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @returns {Promise<void>} - Возвращает промис для синхронизации с другими действиями.
 */
async function createDropdownList(id, filterName, container, gender, age) {
    let isOpen = false; // Флаг для отслеживания состояния открытия списка
    const select = document.createElement('select');
    const searchInput = document.createElement('input');
    let selectedOption = null; // Выбранная опция

    

    try {
        select.id = id;
        const response = await fetch('normal_positions.json');
        const data = await response.json();

        // Фильтруем данные по названию и полу
        const filteredPositions = data.positions.filter(position => {
            return position.name === filterName && position.gender === gender;
        });

        select.addEventListener('change', () => {
            const inputValue = document.getElementById(`${container.id}-input`).value;
            updateGradePanelStatus(inputValue, container.id);


            // Сбрасываем стиль предыдущей выбранной опции
            if (selectedOption) {
                selectedOption.style.color = 'black'; // Синий цвет для не выбранной опции
            }
        
            // Получаем выбранную опцию
            selectedOption = select.options[select.selectedIndex];
            selectedOption.style.color = 'blue'; // Синий цвет для выбранной опции
        
            // Получаем значения границ из выбранной опции
            const bounds = JSON.parse(selectedOption.value);
            
            
        });

        
        


        // Функция для создания опции в списке
        const createOption = (position) => {
            const option = document.createElement('option');
            option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });
        
            // Создаем структуру из span элементов для разных частей текста
            const nameSpan = document.createElement('span');
            nameSpan.textContent = `${position.name} ${position.lowerBound} - ${position.upperBound} ${position.unit} `;
            option.appendChild(nameSpan);
        
            const ageSpan = document.createElement('span');
            ageSpan.textContent = `[Возраст: ${position.ageLowerBound}-${position.ageUpperBound}]`;
            ageSpan.classList.add('gray-text'); // Добавляем класс для серого цвета
            option.appendChild(ageSpan);
        
            if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
                option.classList.add('matched-option');
            }
        
            select.appendChild(option);
        
            // Проверяем, соответствует ли текущая опция всем условиям фильтрации
            if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
                selectedOption = option;
            }
        };
        


        // Функция для фильтрации поискового запроса
        const filterOptions = (searchTerm) => {
            const lowerCaseSearch = searchTerm.toLowerCase();
            select.innerHTML = ''; // Очищаем список перед добавлением отфильтрованных элементов

            filteredPositions.forEach(position => {
                // Преобразуем диапазон в строку для поиска
                const rangeString = `${position.lowerBound}-${position.upperBound}`;

                // Проверяем, содержится ли поисковый запрос в названии, единице измерения или диапазоне
                if (position.name.toLowerCase().includes(lowerCaseSearch) ||
                    position.unit.toLowerCase().includes(lowerCaseSearch) ||
                    rangeString.includes(lowerCaseSearch)) {
                    createOption(position);
                }
            });

            // Показываем или скрываем инпут для поиска в зависимости от наличия отфильтрованных элементов
            if (select.options.length > 0) {
                searchInput.style.display = 'block';
            } else {
                searchInput.style.display = 'none';
            }
        };

        // Инициализация инпута для поиска
        searchInput.type = 'text';
        searchInput.placeholder = 'Поис ...';
        searchInput.classList.add('search-input'); // Добавляем класс для стилей
        searchInput.style.display = 'none'; // Начинаем с скрытым инпутом
        searchInput.addEventListener('input', () => {
            filterOptions(searchInput.value.trim());
        });
        container.appendChild(searchInput);

        // Добавляем выпадающий список в контейнер
        container.appendChild(select);

        // Обработчик клика по выпадающему списку для открытия/закрытия инпута поиска
        select.addEventListener('click', (event) => {
            event.stopPropagation(); // Остановка всплытия события, чтобы клик по select не срабатывал на документе
            isOpen = !isOpen;
            if (isOpen) {
                searchInput.style.display = 'block';
            } else {
                searchInput.style.display = 'none';
            }
        });

        // Добавляем обработчик изменения для обновления стиля
        select.addEventListener('change', () => {
            if (selectedOption && selectedOption.classList.contains('matched-option')) {
                select.classList.add('matched-select');
                
            } else {
                select.classList.remove('matched-select');
                
            }
        });

        // Инициализируем выпадающий список с текущими фильтрованными данными
        filteredPositions.forEach(createOption);

        

        // Если найдена соответствующая опция при загрузке, делаем её выбранной
        if (selectedOption) {
            selectedOption.selected = true;
        }

        // Обработчик клика на документе для закрытия инпута, если кликнуто вне контейнера
        document.addEventListener('click', (event) => {
            const isClickedInside = container.contains(event.target);
            if (!isClickedInside) {
                isOpen = false;
                searchInput.style.display = 'none';
                
            }
        });

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}





Посмотри. У нас есть вот это:   



// Глобальная переменная для хранения выбранного пола
let gender = null;
let age = null; // Глобальная переменная для хранения возраста
let laboratory = null;
let tarif = null;

// Функция для создания контейнера с параметрами и добавления в него элементов
        function createParametriaContainer(gender, age) {
            // Проверяем, существует ли уже контейнер с параметрами
            const existingContainer = document.getElementById('parametria');
            if (existingContainer) {
                // Если контейнер существует, удаляем его
                existingContainer.remove();
            }

            // Создаем новый контейнер
            const parametriaContainer = document.createElement('div');
            parametriaContainer.id = 'parametria';
            parametriaContainer.classList.add('parametria-class'); // Добавляем класс

            // Добавляем контейнер на страницу (в body)
            document.body.appendChild(parametriaContainer);

            if (tarif === 'Хромолаб PRO 1.1') {
                // Создаем элементы в контейнере в зависимости от выбранного пола и возраста
                createContainerWithInput('Литий', 'minerals', 1, gender, age, parametriaContainer);
                createContainerWithInput('Натрий', 'minerals', 2, gender, age, parametriaContainer);
                createContainerWithInput('Кальций', 'minerals', 3, gender, age, parametriaContainer);
            }

            if (tarif === 'Хромолаб PRO PLUS 1.0') {
                // Создаем элементы в контейнере в зависимости от выбранного пола и возраста
                createContainerWithInput('Литий', 'minerals', 1, gender, age, parametriaContainer);
                createContainerWithInput('Натрий', 'minerals', 2, gender, age, parametriaContainer);
            }
        }


        И это:

        /**
 * Создает контейнер с заголовком, содержащий инпут для умного ввода числовых значений,
 * используя данные из JSON файла.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 */
async function createContainerWithInput(id, type, number, gender, age, parentContainer) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    try {
        // Загружаем данные из JSON файла
        const response = await fetch('data.json');
        const data = await response.json();

        // Определяем заголовок контейнера в зависимости от типа и номера
        let headerText = 'Unknown Type';

        if (data[type] && data[type][number.toString()]) {
            headerText = data[type][number.toString()];
        }

        // Проверяем количество уже существующих контейнеров с данным типом
        const existingContainers = parentContainer.querySelectorAll(`.inputContainer[data-type="${type}"]`);
        const containerCount = existingContainers.length + 1;

        // Вставляем заголовок в начало контейнера
        container.textContent = `${containerCount}. ${headerText}`;
        container.setAttribute('data-type', type); // Добавляем атрибут для удобства подсчета

        

        // Добавляем контейнер в родительский контейнер
        parentContainer.appendChild(container);

        // Создаем переключатель чекбокса
        createCheckboxToggle(id, false);

        // Создаем выпадающий список перед инпутом
        await createDropdownList(`${id}-dropdown`, headerText, container, gender, age, tarif);

        

        // Создаем инпут с помощью функции createSmartInput, передав ID контейнера
        createSmartInput(`${id}-input`, 10, 6, id); // Пример использования createSmartInput с генерацией уникального ID для инпута

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}


Можно ли сделать так, что при повторном вызове функции createParametriaContainer - те createContainerWithInput у которых
в инпутах что-то есть, то эти контейнеры бы не удалялись а при создании новых createParametriaContainer если есть такой же
createParametriaContainer, например:

if (tarif === 'Хромолаб PRO 1.1') {
                // Создаем элементы в контейнере в зависимости от выбранного пола и возраста
                createContainerWithInput('Литий', 'minerals', 1, gender, age, parametriaContainer);
                createContainerWithInput('Натрий', 'minerals', 2, gender, age, parametriaContainer);
                createContainerWithInput('Кальций', 'minerals', 3, gender, age, parametriaContainer);
            }

            if (tarif === 'Хромолаб PRO PLUS 1.0') {
                // Создаем элементы в контейнере в зависимости от выбранного пола и возраста
                createContainerWithInput('Литий', 'minerals', 1, gender, age, parametriaContainer);
                createContainerWithInput('Натрий', 'minerals', 2, gender, age, parametriaContainer);
            }

            (видишь, они повторяются. Так вот точно такой же просто при повторном исполнении функции не замещает старый)













Смотри у нас есть вот это:

// Глобальный массив для хранения состояний чекбоксов
const checkboxStates = [];

/**
 * Асинхронно создает переключатель чекбокса.
 * @param {string} id - Идентификатор элемента, куда будет вставлен чекбокс.
 * @param {boolean} defaultValue - Значение по умолчанию (true - включен, false - выключен).
 */
async function createCheckboxToggle(id, defaultValue) {
    try {
        // Находим элемент, куда нужно вставить переключатель
        const container = document.getElementById(id);
        
        // Создаем элементы чекбокса
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = defaultValue;
        
        // Добавляем информацию о чекбоксе в массив checkboxStates
        checkboxStates.push({ id, checked: defaultValue });

        // Добавляем классы для стилизации (будут определены в CSS)
        checkbox.classList.add('toggle-checkbox');
        
        // Устанавливаем стиль для смещения чекбокса на 550 пикселей влево
        checkbox.style.position = 'absolute';
        checkbox.style.left = '100px';
        checkbox.style.border = '1px solid rgba(78, 78, 78, 0.25)';
        checkbox.style.borderRadius = '20px';
        
        // Добавляем обработчик события изменения состояния чекбокса
        checkbox.addEventListener('change', function() {
            if (checkbox.checked) {
                checkbox.style.backgroundColor = '#c295343f';
                checkbox.style.borderColor = 'rgba(78, 78, 78, 0.25)';
            } else {
                checkbox.style.backgroundColor = 'white';
                checkbox.style.borderColor = 'rgba(78, 78, 78, 0.25)';
            }
            // Обновляем значение в массиве checkboxStates
            const index = checkboxStates.findIndex(item => item.id === id);
            if (index !== -1) {
                checkboxStates[index].checked = checkbox.checked;
            }
            console.log(`Чекбокс ${id} изменен: ${checkbox.checked}`);
        });
        
        // Добавляем чекбокс в контейнер
        container.appendChild(checkbox);
    } catch (error) {
        console.error('Error creating checkbox:', error);
    }
}

И это:

/**
 * Создает контейнер с заголовком, содержащий инпут для умного ввода числовых значений,
 * используя данные из JSON файла.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 */
async function createContainerWithInput(id, type, number, gender, age, parentContainer) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    try {
        // Загружаем данные из JSON файла
        const response = await fetch('data.json');
        const data = await response.json();

        // Определяем заголовок контейнера в зависимости от типа и номера
        let headerText = 'Unknown Type';

        if (data[type] && data[type][number.toString()]) {
            headerText = data[type][number.toString()];
        }

        // Проверяем количество уже существующих контейнеров с данным типом
        const existingContainers = parentContainer.querySelectorAll(`.inputContainer[data-type="${type}"]`);
        const containerCount = existingContainers.length + 1;

        // Вставляем заголовок в начало контейнера
        container.textContent = `${containerCount}. ${headerText}`;
        container.setAttribute('data-type', type); // Добавляем атрибут для удобства подсчета

        

        // Добавляем контейнер в родительский контейнер
        parentContainer.appendChild(container);

        // Создаем переключатель чекбокса
        createCheckboxToggle(id, false);

        // Создаем выпадающий список перед инпутом
        await createDropdownList(`${id}-dropdown`, headerText, container, gender, age, tarif);

        

        // Создаем инпут с помощью функции createSmartInput, передав ID контейнера
        createSmartInput(`${id}-input`, 10, 6, id); // Пример использования createSmartInput с генерацией уникального ID для инпута

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}

Можно ли при включенном чекбоксе этого же контейнера блокировать в этом контейнере выпадающий список и инпут?










Поддержка Хромолаб
Приложения
вт, 24 нояб., 11:06 (1 день назад)
кому: я

Добрый день, Евгения.
 
Витамин В 9 (фолиевая кислота, Folic acid, Фолат)
3,1 - 19,9 нг/мл
 
ТТГ (тиреотропный гормон)
Мужчины:
до 1 года: 0.88-5.42 мкМЕ/мл
от 1 года: 0.67-4.5 мкМЕ/мл
от 11 лет: 0.58-3.59 мкМЕ/мл
от 15 лет: 0.35-4.94 мкМЕ/мл
Женщины:
до 1 года: 0.88-5.42 мкМЕ/мл
от 1 года: 0.66-4.75 мкМЕ/мл
от 11 лет: 0.47-4.13 мкМЕ/мл
от 15 лет: 0.35-4.94 мкМЕ/мл
референсные значения для беременных:
I триместр – 0,1 - 2,5 мкМЕ/мл
II  триместр – 0,2 - 3 мкМЕ/мл
III  триместр – 0,3 - 3 мкМЕ/мл
 
Инсулин
2,3 - 26,4 мкМЕ/мл
 
АЛТ (аланинаминотрансфераза)
Общие от 0 дней: 13-45 Е/л
Мужчины от 1 года: 0-50 Е/л
Женщины от 1 года: 0-35 Е/л
 
АСТ (аспартатаминотрансфераза)
Общие от 0 дней: 25-75 Е/л
Общие от 4 недель: 15-60 Е/л
Мужчины от 1 года: 0-50 Е/л
Женщины от 1 года: 0-35 Е/л
 
Глюкоза
От 2 дней: 2,8-4,4 ммоль/л
От 1 месяца: 3,3-5,6 ммоль/л
От 17 лет: 4,1-5,9 ммоль/л
От 60 лет: 4,6-6,4 ммоль/л
 
Согласно рекомендациям ВОЗ (1999-2013), "Диагностические критерии сахарного диабета и других нарушений гликемии":
Нормальный уровень глюкозы натощак: < 6,1 ммоль/л
Нормальный уровень глюкозы натощак у беременных: < 5,1 ммоль/л
Диагностические критерии сахарного диабета:
уровень глюкозы натощак: ≥ 7,0 ммоль/л
уровень глюкозы при случайном определении: ≥ 11,1 ммоль/л
 
Креатинин
общие от 0 недель: 45-105 мкмоль/л
общие от 1 недель: 35-62 мкмоль/л
общие от 1 лет: 45-105 мкмоль/л
мужчины от 15 лет: 74-110 мкмоль/л
мужчины от 50 лет: 72-127 мкмоль/л
женщины от 15 лет: 58-96 мкмоль/л
 
Мочевая кислота
мужчины: 208.3-428.4 мкмоль/л
женщины: 154.7-357 мкмоль/л
 
Холестерин общий
Возраст (лет)                   Мужчины    Женщины (ммоль/л)
от 0                                       2,95-5,25    2,9-5,18    
от 5                                       3,13-5,25    3,26-5,3
от 10                                     3,08-5,23    3,21-5,2
от 15                                     2,93-5,1      3,08-5,18
от 20                                     3,21-5,64    3,16-5,59
от 25                                     3,44-6,32    3,32-5,75
от 30                                     3,57-6,58    3,37-5,96
от 35                                     3,78-6,99    3,63-6,27
от 40                                     3,91-6,94    3,81-6,53
от 45                                     4,09-7,15    3,94-6,86
от 50                                     4,09-7,17    4,2-7,38
от 55                                     4,04-7,15    4,45-7,77
от 60                                     4,12-7,15    4,45-7,69
от 65                                     4,09-7,10    4,43-7,85
от 70                                     3,73-6,86    4,48-7,25
Референсный диапазон указан согласно Клиническому руководству по лабораторным тестам под редакцией Н. Тица.
Рекомендованные значения National Cholesterol Education Program Adult Treatment Panel III для оценки риска: 
< 5,2 ммоль/л - нормальные значения
5,2 - 6,2 ммоль/л - пограничные значения
≥ 6,2 ммоль/л - высокие значения
Рекомендованные значения European Atherosclerosis Society для оценки риска:
Холестерин < 5,2 ммоль/л; Триглицериды < 2,3 ммоль/л - нет нарушений липидного обмена
Холестерин 5,2–7,8 ммоль/л - нарушения липидного обмена, если холестерин ЛПВП < 0,9 ммоль/л
Холестерин > 7,8 ммоль/л; Триглицериды > 2,3 ммоль/л - нарушения липидного обмена
 
Железо
общие от 0 дней: 17.9-44.8 мкмоль/л
общие от 7 дней: 7.2-17.9 мкмоль/л
общие от 1 лет: 9-21.5 мкмоль/л
мужчины от 17 лет: 12.5-32.2 мкмоль/л
женщины от 17 лет: 10.7-32.2 мкмоль/л
 
Ферритин
общие от 0 месяцев: 6-400 мкг/л
общие от 1 месяцев: 6-410 мкг/л
общие от 6 месяцев: 6-80 мкг/л
общие от 1 лет: 6-60 мкг/л
общие от 6 лет: 6-320 мкг/л
мужчины от 19 лет: 20-250 мкг/л
женщины от 19 лет: 10-150 мкг/л
 
Гомоцистеин
мужчины: 5,46-16,20 мкмоль/л 
женщины: 4,44-13,56 мкмоль/л
--------
С уважением,

Козина Полина 
Менеджер по работе с корпоративными клиентами



надо сдвинуть в контейнере параметра все на 200 пикселей вправо

базовые:


селект
left: 250px;

инпут
left: 669px;

статус
left: 801px;


лейблы

нормы
left: 285px;

значения 
left: 700px;

грейды
left: 830px;


прочее

индикатор:
left: 210px;

переключатель
checkbox.style.left = '100px';





отображение возраста

ageSpan.style.display = 'none';
ageSpan.textContent = `[Возраст: ${position.ageLowerBound}-${position.ageUpperBound}]`;



if (isOpen) {
            const ageSpan = document.createElement('span');
            ageSpan.textContent = `[Возраст: ${position.ageLowerBound}-${position.ageUpperBound}]`;
            ageSpan.classList.add('gray-text'); // Добавляем класс для серого цвета
            option.appendChild(ageSpan);
        }











Помоги пожалуйста с кодом. Смотри, если в верхней границе нормы (не возраста а просто параметра) стоит символ
        "∞"  - то мы его таким и добавим в список, однако это будет маской ведь на деле это будет обрабатываться
        как число 999999


        /**
 * Создает выпадающий список с элементами, извлечёнными из JSON файла.
 * @param {string} id - ID выпадающего списка.
 * @param {string} filterName - Имя для фильтрации позиций в JSON файле.
 * @param {HTMLElement} container - Контейнер, в который будет добавлен выпадающий список.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {string} tarif - Номер текущей панели.
 * @returns {Promise<void>} - Возвращает промис для синхронизации с другими действиями.
 */
async function createDropdownList(id, filterName, container, gender, age, tarif) {
    let isOpen = false; // Флаг для отслеживания состояния открытия списка
    const select = document.createElement('select');
    const searchInput = document.createElement('input');
    let selectedOption = null; // Выбранная опция

    try {
        select.id = id;
        const response = await fetch('normal_positions.json');
        const data = await response.json();

        // Фильтруем данные по названию, полу и панели
        const filteredPositions = data.positions.filter(position => {
            return position.name === filterName && position.gender === gender && position.panel === tarif;
        });

        select.addEventListener('change', () => {
            const inputValue = document.getElementById(`${container.id}-input`).value;
            updateGradePanelStatus(inputValue, container.id);

            // Сбрасываем стиль предыдущей выбранной опции
            if (selectedOption) {
                selectedOption.style.color = 'black'; // Черный цвет для не выбранной опции
            }

            // Получаем выбранную опцию
            selectedOption = select.options[select.selectedIndex];
            selectedOption.style.color = 'blue'; // Синий цвет для выбранной опции

            // Получаем значения границ из выбранной опции
            const bounds = JSON.parse(selectedOption.value);
        });

        // Функция для создания опции в списке
        const createOption = (position) => {
            const option = document.createElement('option');
            option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });

            // Создаем структуру из span элементов для разных частей текста
            const nameSpan = document.createElement('span');
            nameSpan.textContent = `${position.name} ${position.lowerBound} - ${position.upperBound} ${position.unit} `;
            option.appendChild(nameSpan);

            

        

            

            if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
                option.classList.add('matched-option');
            }

            select.appendChild(option);

            // Проверяем, соответствует ли текущая опция всем условиям фильтрации
            if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
                selectedOption = option;
            }
        };

        

        // Функция для фильтрации поискового запроса
        const filterOptions = (searchTerm) => {
            const lowerCaseSearch = searchTerm.toLowerCase();
            select.innerHTML = ''; // Очищаем список перед добавлением отфильтрованных элементов

            filteredPositions.forEach(position => {
                // Преобразуем диапазон в строку для поиска
                const rangeString = `${position.lowerBound}-${position.upperBound}`;

                // Проверяем, содержится ли поисковый запрос в названии, единице измерения или диапазоне
                if (position.name.toLowerCase().includes(lowerCaseSearch) ||
                    position.unit.toLowerCase().includes(lowerCaseSearch) ||
                    rangeString.includes(lowerCaseSearch)) {
                    createOption(position);
                }
            });

            // Показываем или скрываем инпут для поиска в зависимости от наличия отфильтрованных элементов
            if (select.options.length > 0) {
                searchInput.style.display = 'block';
            } else {
                searchInput.style.display = 'none';
            }
        };

        // Инициализация инпута для поиска
        searchInput.type = 'text';
        searchInput.placeholder = 'Поиск...';
        searchInput.classList.add('search-input'); // Добавляем класс для стилей
        searchInput.style.display = 'none'; // Начинаем со скрытым инпутом
        searchInput.addEventListener('input', () => {
            filterOptions(searchInput.value.trim());
        });
        container.appendChild(searchInput);

        
        

        // Добавляем выпадающий список в контейнер
        container.appendChild(select);

        // Обработчик клика по выпадающему списку для открытия/закрытия инпута поиска
        select.addEventListener('click', (event) => {
            event.stopPropagation(); // Остановка всплытия события, чтобы клик по select не срабатывал на документе
            isOpen = !isOpen;
            if (isOpen) {
                searchInput.style.display = 'block';
                searchInput.style.backgroundColor = 'white';
                searchInput.style.border = '1px solid #00a2ff8e';
                searchInput.style.boxShadow = 'inset 0 0 15px rgba(156, 156, 156, 0.5)';

                
                
            } else {
                searchInput.style.display = 'none';
            }

           
        });

        // Обработчик для ховера над searchInput
searchInput.addEventListener('mouseenter', () => {
    // Действия при наведении курсора
    searchInput.style.backgroundColor = '#f0f0f0'; // Пример стиля для подсветки при ховере
    searchInput.style.border = '1px solid #00a2ff'; // Пример изменения границы при ховере
});

searchInput.addEventListener('mouseleave', () => {
    // Действия при уходе курсора
    searchInput.style.backgroundColor = 'white'; // Возвращаем исходный цвет при уходе курсора
    searchInput.style.border = '1px solid #dddddd'; // Возвращаем исходную границу при уходе курсора
});

// Обработчик для фокуса на searchInput
searchInput.addEventListener('focus', () => {
    // Действия при фокусе на элементе
    searchInput.style.outline = '1px solid #00a2ff'; // Пример стиля для обводки при фокусе
});

searchInput.addEventListener('blur', () => {
    // Действия при потере фокуса элементом
    searchInput.style.outline = 'none'; // Убираем обводку при потере фокуса
});

        // Добавляем обработчик изменения для обновления стиля
        select.addEventListener('change', () => {
            if (selectedOption && selectedOption.classList.contains('matched-option')) {
                select.classList.add('matched-select');
            } else {
                select.classList.remove('matched-select');
            }
        });

        // Инициализируем выпадающий список с текущими фильтрованными данными
        filteredPositions.forEach(createOption);

        // Если найдена соответствующая опция при загрузке, делаем её выбранной
        if (selectedOption) {
            selectedOption.selected = true;
        }

        // Обработчик клика на документе для закрытия инпута, если кликнуто вне контейнера
        document.addEventListener('click', (event) => {
            const isClickedInside = container.contains(event.target);
            if (!isClickedInside) {
                isOpen = false;
                searchInput.style.display = 'none';
            }
        });

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}





отлично, но в этой клиентской глобальной переменной лаборатории у нас будет указываться айди из файла labs.json, 
там структура такая в файле:    

[
    { "id": 1, "name": "Хромолаб" },
    { "id": 2, "name": "Медси" },
    { "id": 3, "name": "KDL" },
    { "id": 4, "name": "Invitro" }
]


мне нужно чтобы здесь clientLaboratoryLabel.textContent = `Лаборатория сдачи: ${clientLaboratory}`; 

в    clientLaboratory     мы получали name из того файла, которое соответствует айди. Возможно
для этого придется придумать функцию преобразования айди и затем ее тут применить






можно ли используя текущее значение глобальной переменной clientTariff (читая значения по ключевым
совпадающим буквам) выставлять по умолчанию выбранную панель? Покажи тольк тот участок кода, который
надо улучшить. Вот код:


const clientName = "Капеев Александр Викторович"; // Глобальная переменная для ФИО клиента
const clientGender = "male"; // Глобальная переменная для пола клиента
const clientBirthDate = "23-05-1988"; // Глобальная переменная для даты рождения клиента в формате дд.мм.гггг
const clientLaboratory = 1; // Глобальная переменная лаборатории, где клиент сдавал анализы
const clientDeliveryDateTime = "27-06-2024 10:00"; // Пример значения даты и времени сдачи
const clientTariff = "PRO"; // Пример значения клиентского тарифа



// Глобальная переменная для хранения выбранного пола
let gender = null;
let age = null; // Глобальная переменная для хранения возраста
let laboratory = null;
let tarif = null;

// Глобальный счетчик контейнеров
let globalContainerCount = 0;



// Симуляция данных из labs.json
const labsData = [
    { "id": 1, "name": "Хромолаб" },
    { "id": 2, "name": "Медси" },
    { "id": 3, "name": "KDL" },
    { "id": 4, "name": "Invitro" }
];

// Функция для преобразования значения пола
function displayGender(genderValue) {
    return genderValue === "male" ? "Мужской" : "Женский";
}

// Функция для вычисления возраста на основе даты рождения
function calculateAge(birthDate) {
    const [day, month, year] = birthDate.split('-');
    const birthDateObj = new Date(`${year}-${month}-${day}`);
    const today = new Date();
    let age = today.getFullYear() - birthDateObj.getFullYear();
    const monthDiff = today.getMonth() - birthDateObj.getMonth();
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDateObj.getDate())) {
        age--;
    }
    return age;
}

// Функция для получения имени лаборатории по ID
function getLaboratoryNameById(id) {
    const lab = labsData.find(lab => lab.id === id);
    return lab ? lab.name : 'Неизвестная лаборатория'; // Возвращаем имя или дефолтное значение, если лаборатория не найдена
}


function calculateTimeElapsed(deliveryDateTime) {
    const [datePart, timePart] = deliveryDateTime.split(' ');
    const [day, month, year] = datePart.split('-');
    const [hour, minute] = timePart.split(':');

    const deliveryDateObj = new Date(year, month - 1, day, hour, minute);
    const now = new Date();

    // Проверяем, если дата сдачи еще не наступила
    if (now < deliveryDateObj) {
        return '[ошибка, исправьте дату]';
    }

    // Разница в миллисекундах
    let diffMilliseconds = now - deliveryDateObj;

    // Количество миллисекунд в минуте, часе, дне и неделе
    const msPerMinute = 1000 * 60;
    const msPerHour = msPerMinute * 60;
    const msPerDay = msPerHour * 24;
    const msPerWeek = msPerDay * 7;
    const msPerMonth = msPerDay * 30.44; // Среднее количество дней в месяце
    const msPerYear = msPerDay * 365.25; // Среднее количество дней в году

    // Вычисляем количество лет, месяцев, недель, дней, часов и минут
    let years = Math.floor(diffMilliseconds / msPerYear);
    diffMilliseconds %= msPerYear;
    let months = Math.floor(diffMilliseconds / msPerMonth);
    diffMilliseconds %= msPerMonth;
    let weeks = Math.floor(diffMilliseconds / msPerWeek);
    diffMilliseconds %= msPerWeek;
    let days = Math.floor(diffMilliseconds / msPerDay);
    diffMilliseconds %= msPerDay;
    let hours = Math.floor(diffMilliseconds / msPerHour);
    diffMilliseconds %= msPerHour;
    let minutes = Math.floor(diffMilliseconds / msPerMinute);

    // Формируем строку с прошедшим временем
    let timeElapsedString = '[прошло ';
    let added = false;

    if (years > 0) {
        timeElapsedString += `${years} лет`;
        added = true;
    }
    if (months > 0) {
        if (added) timeElapsedString += ', ';
        timeElapsedString += `${months} месяцев`;
        added = true;
    }
    if (weeks > 0) {
        if (added) timeElapsedString += ', ';
        timeElapsedString += `${weeks} недель`;
        added = true;
    }
    if (days > 0) {
        if (added) timeElapsedString += ', ';
        timeElapsedString += `${days} дней`;
        added = true;
    }
    if (hours > 0 && !(years > 0 || months > 0 || weeks > 0 || days > 0)) {
        if (added) timeElapsedString += ', ';
        timeElapsedString += `${hours} часов`;
        added = true;
    }
    if (minutes > 0 && !(years > 0 || months > 0 || weeks > 0 || days > 0 || hours > 0)) {
        if (added) timeElapsedString += ', ';
        timeElapsedString += `${minutes} минут`;
    }

    timeElapsedString += ']';

    return timeElapsedString;
}












// Глобальная функция для создания лейблов
function createLabels(container) {
    // Создаем лейблы
    const labels = [
        { text: 'Параметры:', class: 'label-parameters', id: 'label-parameters' },
        { text: 'Нормы:', class: 'label-norms', id: 'label-norms' },
        { text: 'Значения:', class: 'label-values', id: 'label-values' },
        { text: 'Грейды:', class: 'label-grades', id: 'label-grades' }
    ];

    // Добавляем каждый лейбл в указанный контейнер
    labels.forEach(label => {
        const labelElement = document.createElement('div');
        labelElement.textContent = label.text;
        labelElement.classList.add(label.class);
        labelElement.id = label.id;
        container.appendChild(labelElement);
    });
}

// Функция для создания контейнера с параметрами и добавления в него элементов
function createParametriaContainer(gender, age) {
    // Проверяем, существует ли уже контейнер с параметрами
    const existingContainer = document.getElementById('parametria');
    if (existingContainer) {
        // Если контейнер существует, удаляем его
        existingContainer.remove();
    }

    // Создаем новый контейнер
    globalContainerCount = 0;
    const parametriaContainer = document.createElement('div');
    parametriaContainer.id = 'parametria';
    parametriaContainer.classList.add('parametria-class'); // Добавляем класс

    // Создаем лейблы и добавляем их в контейнер
    createLabels(parametriaContainer);

    // Добавляем контейнер на страницу (в body)
    document.body.appendChild(parametriaContainer);

    if (tarif === 'Хромолаб PRO 1.1') {
        // Создаем элементы в контейнере в зависимости от выбранного пола и возраста
        createContainerWithInput('АлАТ', 'biochemistry', 1, gender, age, parametriaContainer);
        createContainerWithInput('АсАТ', 'biochemistry', 2, gender, age, parametriaContainer);
        createContainerWithInput('Креатинин', 'biochemistry', 3, gender, age, parametriaContainer);
        createContainerWithInput('Мочевая кислота', 'biochemistry', 4, gender, age, parametriaContainer);
        createContainerWithInput('Триглицериды', 'biochemistry', 5, gender, age, parametriaContainer);
        createContainerWithInput('Холестерин общий (ХС)', 'biochemistry', 6, gender, age, parametriaContainer);
        createContainerWithInput('Холестерин - ЛПВП (альфа-холестерин)', 'biochemistry', 7, gender, age, parametriaContainer);
        createContainerWithInput('Холестерин - ЛПНП (бета-холестерин)', 'biochemistry', 8, gender, age, parametriaContainer);
        createContainerWithInput('Коэффициент атерогенности', 'biochemistry', 9, gender, age, parametriaContainer);
        createContainerWithInput('C-реактивный белок ультрачувствительный', 'biochemistry', 10, gender, age, parametriaContainer);
        
        

        /*
        createContainerWithInput('Литий', 'minerals', 1, gender, age, parametriaContainer);
        createContainerWithInput('Натрий', 'minerals', 2, gender, age, parametriaContainer);
        createContainerWithInput('Кальций', 'minerals', 3, gender, age, parametriaContainer);
        */
    }

    if (tarif === 'Хромолаб PRO PLUS 1.0') {
        // Создаем элементы в контейнере в зависимости от выбранного пола и возраста
        createContainerWithInput('АлАТ', 'biochemistry', 1, gender, age, parametriaContainer);
        createContainerWithInput('АсАТ', 'biochemistry', 2, gender, age, parametriaContainer);

        /*
        createContainerWithInput('Литий', 'minerals', 1, gender, age, parametriaContainer);
        createContainerWithInput('Натрий', 'minerals', 2, gender, age, parametriaContainer);
        */
    }

    if (tarif === 'Хромолаб GEN PRO 1.0') {
        // Создаем элементы в контейнере в зависимости от выбранного пола и возраста
        createContainerWithInput('MTHFR (rs 1801133)', 'genetics', 1, gender, age, parametriaContainer);


        /*
        createContainerWithInput('Литий', 'minerals', 1, gender, age, parametriaContainer);
        createContainerWithInput('Натрий', 'minerals', 2, gender, age, parametriaContainer);
        */
    }
}


/**
 * Создает панель управления (контейнер) с текстом "Пол" и выпадающим списком для выбора пола, а также с возрастом.
 * @param {string} panelId - ID для создаваемой панели управления.
 * @returns {HTMLElement} Возвращает элемент панели управления.
 */
function createControlPanel(panelId) {
    // Создаем элемент панели управления
    const panel = document.createElement('div');
    
    // Присваиваем класс для стилизации
    panel.classList.add('control-panel');

    // Устанавливаем ID, если он был предоставлен
    if (panelId) {
        panel.id = panelId;
    }


    // Создаем контейнер для текста "Клиент"
    const clientLabel = document.createElement('div');
    clientLabel.textContent = `Клиент: ${clientName}`;
    clientLabel.classList.add('client-label');

    // Добавляем контейнер с текстом "Клиент" в панель
    panel.appendChild(clientLabel);

    
    // Создаем контейнер для текста "Пол клиента"
    const clientGenderLabel = document.createElement('div');
    clientGenderLabel.textContent = `Пол: ${displayGender(clientGender)}`; // Показывает текущий пол, но замаскированный под русские значения
    clientGenderLabel.classList.add('client-gender-label');

    // Добавляем контейнер с текстом "Пол клиента" в панель
    panel.appendChild(clientGenderLabel);

    gender = clientGender;


    
     // Вычисляем возраст клиента на основе даты рождения
    const clientAge = calculateAge(clientBirthDate);

    // Создаем контейнер для текста "Дата рождения клиента"
    const clientBirthDateLabel = document.createElement('div');
    clientBirthDateLabel.textContent = `Дата рождения: ${clientBirthDate} [${clientAge} лет]`;
    clientBirthDateLabel.classList.add('client-birthdate-label');

    // Добавляем контейнер с текстом "Дата рождения клиента" в панель
    panel.appendChild(clientBirthDateLabel);

    age = clientAge;
    


    // Добавляем контейнер с текстом "Лаборатория сдачи"
    const clientLaboratoryLabel = document.createElement('div');
    clientLaboratoryLabel.textContent = `Лаборатория сдачи: ${getLaboratoryNameById(clientLaboratory)}`; // здесь должно быть значение переменной laboratory
    clientLaboratoryLabel.classList.add('client-laboratory-label');

    // Добавляем контейнер с текстом "Лаборатория сдачи" в панель
    panel.appendChild(clientLaboratoryLabel);

    laboratory = clientLaboratory;


    // Создаем контейнер для текста "Дата и время сдачи"
    const clientDeliveryLabel = document.createElement('div');
    clientDeliveryLabel.textContent = `Дата и время сдачи: ${clientDeliveryDateTime} ${calculateTimeElapsed(clientDeliveryDateTime)}`;
    clientDeliveryLabel.classList.add('client-delivery-label');

    // Добавляем контейнер с текстом "Дата и время сдачи" в панель
    panel.appendChild(clientDeliveryLabel);


    // Добавляем контейнер с текстом "Клиентский тариф"
    const clientTariffLabel = document.createElement('div');
    clientTariffLabel.textContent = `Клиентский тариф: ${clientTariff}`;
    clientTariffLabel.classList.add('client-tariff-label');

    // Добавляем контейнер с текстом "Клиентский тариф" в панель
    panel.appendChild(clientTariffLabel);



    


    // Создаем контейнер для текста "Пол"
    const genderLabel = document.createElement('div');
    genderLabel.textContent = 'Пол:';
    genderLabel.classList.add('gender-label');

    // Добавляем контейнер с текстом "Пол" в панель
    panel.appendChild(genderLabel);

    // Создаем выпадающий список для выбора пола
    const genderSelect = document.createElement('select');
    genderSelect.classList.add('gender-select');
    genderSelect.style.backgroundColor = 'white';
    genderSelect.style.border = `2px solid #dddddd`;
    genderSelect.style.borderRadius = `20px`;

    // Добавляем обработчик изменения выбора пола
    genderSelect.addEventListener('change', function() {
        gender = this.value; // Обновляем глобальную переменную при изменении выбора
        createParametriaContainer(gender, age); // Создаем контейнер с параметрами
    });

    // Добавляем обработчики событий для изменения стилей при ховере и фокусе
    genderSelect.addEventListener('mouseenter', function() {
        this.style.border = `1px solid #3af`; /* Синий цвет рамки при ховере */
    });

    genderSelect.addEventListener('mouseleave', function() {
        this.style.border = `1px solid #ddd`; /* Возвращаем серый цвет рамки после ховера */
    });

    genderSelect.addEventListener('focus', function() {
        this.style.border = `1px solid #3af`; /* Синий цвет рамки при фокусе */
    });

    genderSelect.addEventListener('blur', function() {
        this.style.border = `1px solid #ddd`; /* Возвращаем серый цвет рамки после фокуса */
    });

    // Добавляем опции в выпадающий список
    const defaultOption = document.createElement('option');
    defaultOption.text = 'Выберите пол';
    genderSelect.appendChild(defaultOption);

    const maleOption = document.createElement('option');
    maleOption.value = 'male';
    maleOption.text = 'Мужской';
    genderSelect.appendChild(maleOption);

    const femaleOption = document.createElement('option');
    femaleOption.value = 'female';
    femaleOption.text = 'Женский';
    genderSelect.appendChild(femaleOption);

    // Маска
    genderSelect.value = gender;

    // Устанавливаем значение по умолчанию из глобальной переменной клиента
    genderSelect.value = clientGender;

    

    // Добавляем выпадающий список в панель
    panel.appendChild(genderSelect);

    // Создаем контейнер для текста "Возраст"
    const ageLabel = document.createElement('div');
    ageLabel.textContent = 'Возраст:';
    ageLabel.classList.add('age-label');
    

    // Добавляем контейнер с текстом "Возраст" в панель
    panel.appendChild(ageLabel);

    // Создаем инпут для ввода возраста
    const ageInput = document.createElement('input');
    ageInput.type = 'number';
    ageInput.placeholder = 'Укажите возраст';
    ageInput.classList.add('age-input');
    ageInput.style.width = '140px'; // Пример установки ширины инпута (можно менять)
    ageInput.style.backgroundColor = 'white';
    ageInput.style.border = `2px solid #dddddd`;
    ageInput.style.borderRadius = `20px`;

    // Устанавливаем значение по умолчанию из глобальной переменной возраста
ageInput.value = age || '';

// Добавляем обработчики событий для изменения стилей при ховере и фокусе
ageInput.addEventListener('mouseenter', function() {
    this.style.border = `1px solid #3af`; /* Синий цвет рамки при ховере */
});

ageInput.addEventListener('mouseleave', function() {
    this.style.border = `1px solid #ddd`; /* Возвращаем серый цвет рамки после ховера */
});

ageInput.addEventListener('focus', function() {
    this.style.border = `1px solid #3af`; /* Синий цвет рамки при фокусе */
});

ageInput.addEventListener('blur', function() {
    this.style.border = `1px solid #ddd`; /* Возвращаем серый цвет рамки после фокуса */
});




    ageInput.addEventListener('input', function() {
        age = parseInt(this.value); // Обновляем глобальную переменную возраста при изменении значения
        createParametriaContainer(gender, age); // Обновляем контейнер с параметрами
    });

    // Добавляем инпут для ввода возраста в панель
    panel.appendChild(ageInput);


    

    fetch('labs.json')
    .then(response => response.json())
    .then(labsData => {
        const labLabel = document.createElement('div');
        labLabel.textContent = 'Лаборатория:';
        labLabel.classList.add('lab-label');
        panel.appendChild(labLabel);

        

        const labSelect = createSelect('lab-select', 'Выберите лабораторию', labsData.map(lab => ({
            value: lab.id,
            text: lab.name
            
        })));

        labSelect.style.backgroundColor = 'white';
            labSelect.style.border = `2px solid #dddddd`;
            labSelect.style.borderRadius = `20px`;

            // Устанавливаем лабораторию по умолчанию
        labSelect.value = laboratory;
        
        

        labSelect.addEventListener('change', function() {
            laboratory = this.value;

            
            
            updateTarifSelect(); 
            
        });

        panel.appendChild(labSelect);

        

        fetch('tarifs.json')
            .then(response => response.json())
            .then(data => {
                tarifData = data; 

                setTimeout(updateTarifSelect, 1000); // Вызываем функцию обновления списка тарифов через 1 секунду

                const tarifLabel = document.createElement('div');
                tarifLabel.textContent = 'Панель:';
                tarifLabel.classList.add('tarif-label');
                panel.appendChild(tarifLabel);

                const tarifSelect = createSelect('tarif-select', 'Выберите панель', []);
                tarifSelect.addEventListener('change', function() {
                    tarif = this.value;
                    createParametriaContainer(gender, age);
                    console.log('Выбрана панель:', tarif);
                });
                panel.appendChild(tarifSelect);

                tarifSelect.style.backgroundColor = 'white';
                    tarifSelect.style.border = `2px solid #dddddd`;
                    tarifSelect.style.borderRadius = `20px`;

                function updateTarifSelect() {

                    
                    
                    const filteredTarifs = tarifData.filter(tarif => tarif.labId == laboratory);
                    const options = filteredTarifs.map(tarif => ({
                        value: tarif.name,
                        text: tarif.name
                        
                    }));
                    tarifSelect.innerHTML = '';

                    

                    const defaultOption = document.createElement('option');
                    defaultOption.text = 'Выберите панель';
                    
                    tarifSelect.appendChild(defaultOption);
                    
                    options.forEach(option => {
                        const optionElement = document.createElement('option');
                        optionElement.value = option.value;
                        optionElement.text = option.text;
                        tarifSelect.appendChild(optionElement);
                    });
                }

                
                labSelect.addEventListener('change', updateTarifSelect);
            })
            .catch(error => {
                console.error('Ошибка при загрузке tarifs.json:', error);
            });
    })
    .catch(error => {
        console.error('Ошибка при загрузке labs.json:', error);
    });

return panel;
}

/**
 * Создает выпадающий список (select) с указанными опциями.
 *
 * @param {string} className - Класс для создаваемого элемента select.
 * @param {string} defaultOptionText - Текст первой опции (подсказка).
 * @param {Array} options - Массив объектов с опциями для списка в формате {value, text}.
 * @returns {HTMLElement} Возвращает элемент выпадающего списка (select).
 */
function createSelect(className, defaultOptionText, options) {
    // Создаем элемент select и добавляем ему класс
    const select = document.createElement('select');
    select.classList.add(className);

    // Создаем и добавляем элемент option для подсказки
    const defaultOption = document.createElement('option');
    defaultOption.text = defaultOptionText;
    select.appendChild(defaultOption);

    // Проходим по массиву options и создаем элементы option для каждого объекта
    options.forEach(option => {
        const optionElement = document.createElement('option');
        optionElement.value = option.value;
        optionElement.text = option.text;
        select.appendChild(optionElement);
    });

    // Возвращаем созданный элемент select
    return select;
}



// Пример использования функции для создания панели управления с ID 'controlPanel'
const controlPanel = createControlPanel('controlPanel');
document.body.appendChild(controlPanel);



да, но тут дело в том, что контейнеры по группам мы будем размещать только в определенных контейнерных группах, но при этом
класс у контейнерных групп остается тот же. Смотри у нас есть файл data.json со следующей структурой:

{
    "vitamins": {
      "group_id": "001",
      "name": "Витамины",
      "1": "Витамин B1",
      "2": "Витамин B2",
      "3": "Витамин C"
    },
    "minerals": {
      "group_id": "002",
      "name": "Минералы",
      "1": "Литий",
      "2": "Натрий",
      "3": "Кальций"
    },
    "biochemistry": {
      "group_id": "003",
      "name": "Биохимия",
      "1": "АлАТ",
      "2": "АсАТ",
      "3": "Креатинин",
      "4": "Мочевая кислота",
      "5": "Триглицериды",
      "6": "Холестерин общий (ХС)",
      "7": "Холестерин - ЛПВП (альфа-холестерин)",
      "8": "Холестерин - ЛПНП (бета-холестерин)",
      "9": "Коэффициент атерогенности",
      "10": "C-реактивный белок ультрачувствительный"
      
      
      
    },
    "genetics": {
      "group_id": "004",
      "name": "Генетика",
      "1": "MTHFR (rs 1801133)"

    }
  }

  Вдобавок мы будем еще читать файл panels.json (из той же папки проекта) с такой структурой:

  {
    "Хромолаб PRO 1.1": {
      "id": 1,
      "options": ["biochemistry", "minerals"]
    }
  }


  Мне нужно, чтобы в функции createElementsGroup мы использовали первый входной аргумент тариф и на его основе искали
  значение с таким же названием в файле panels.json, там он есть и называется Хромолаб PRO 1.1 (но в будущем я добавлю еще тарифы
  в этом файле). Затем мы берем оттуда все значения из options, после этого идем уже в файл data.json, ищем такие же группы
  параметров, которые мы ранее узнали из массива options. Далее создаем контейнер, он будет иметь айди уже из конкретной группы
  параметров (название переменной контейнера будет соответствовать названию группы параметров на английском), заголовок из name, 
  затем как видишь там есть цифры с закрепленными именами конкретных параметров, мы будем
  проходиться по каждому из них вызывая при этом функцию createContainerWithInput, где первый аргумент внутри будет именем этого
  параметра, второй аргумент названием группы параметров, которое идет у нас в data.json на английском, третий аргумент будет
  цифра самого параметра, четвертый и пятый аргумент остаются без изменений - gender и age, а пятый аргумент это переменная контейнера
  группы. Таких групповых контейнеров может создаваться несколько внутри которых будут параметры, все будет зависеть от размера
  массива в options. И таким образом мне удастся полностью автоматизировать этот процесс и не писать вручную очень много кода, 
  надеюсь ты поможешь с этим. Буду очень благодарен.










Нужно улучшить код, смотри, сейчас он добавляет позиции в выпадающий список, которые соответствуют полу, но что
если значение будет all вместо male или female в джейсон файле? С All будут показываться независимо от пола.

Вот код для улучшения: 


/**
 * Создает выпадающий список с элементами, извлечёнными из JSON файла.
 * @param {string} id - ID выпадающего списка.
 * @param {string} filterName - Имя для фильтрации позиций в JSON файле.
 * @param {HTMLElement} container - Контейнер, в который будет добавлен выпадающий список.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {string} tarif - Номер текущей панели.
 * @returns {Promise<void>} - Возвращает промис для синхронизации с другими действиями.
 */
async function createDropdownList(id, filterName, container, gender, age, tarif) {
    let isOpen = false; // Флаг для отслеживания состояния открытия списка
    const select = document.createElement('select');
    const searchInput = document.createElement('input');
    let selectedOption = null; // Выбранная опция

    try {
        select.id = id;
        const response = await fetch('normal_positions.json');
        const data = await response.json();

        // Фильтруем данные по названию, полу и панели
        const filteredPositions = data.positions.filter(position => {
            return position.name === filterName && position.gender === gender && position.panel === tarif;
        });

        select.addEventListener('change', () => {
            const inputValue = document.getElementById(`${container.id}-input`).value;
            updateGradePanelStatus(inputValue, container.id);

            // Сбрасываем стиль предыдущей выбранной опции
            if (selectedOption) {
                selectedOption.style.color = 'black'; // Черный цвет для не выбранной опции
            }

            // Получаем выбранную опцию
            selectedOption = select.options[select.selectedIndex];
            selectedOption.style.color = 'blue'; // Синий цвет для выбранной опции

            // Получаем значения границ из выбранной опции
            const bounds = JSON.parse(selectedOption.value);
        });

        // Функция для загрузки JSON файла
async function loadGeneticCodes() {
    try {
        const response = await fetch('genetic_codes.json');
        if (!response.ok) {
            throw new Error('Failed to load genetic_codes.json');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error loading genetic_codes.json:', error);
        return null;
    }
}



// Пример функции createOption, которая использует данные из genetic_codes.json
const createOptionGen = async (position) => {
    // Загрузка данных из genetic_codes.json
    const geneticCodes = await loadGeneticCodes();

    if (!geneticCodes) {
        console.error('Failed to load genetic codes data.');
        return;
    }

    const option = document.createElement('option');
    let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте

    // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
    if (position.upperBound === '∞') {
        position.upperBound = 999999;
        upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
    }

    // Функция для замены числовых значений на буквенные коды
    const replaceGeneticCodes = (value) => {
        for (let key in geneticCodes) {
            if (geneticCodes.hasOwnProperty(key)) {
                value = value.replace(new RegExp(geneticCodes[key], 'g'), key);
            }
        }
        return value;
    };

    // Применяем замену на буквенные коды в тексте опции
    const nameSpan = document.createElement('span');
    nameSpan.textContent = `${position.name} ${replaceGeneticCodes(`${position.lowerBound}-${upperBoundDisplay}`)} ${position.unit}`;
    option.appendChild(nameSpan);

    option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });

    // Добавляем класс, если возраст находится в заданном диапазоне
    if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
        option.classList.add('matched-option');
    }

    select.appendChild(option);

    // Проверяем, соответствует ли текущая опция всем условиям фильтрации
    if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
        selectedOption = option;
    }
};




    const createOption = (position) => {
        const option = document.createElement('option');
        let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте
    
        // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
        if (position.upperBound === '∞') {
            position.upperBound = 999999;
            upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
        }
    
        // Преобразуем числовые границы в буквенные коды для отображения на сайте
        const letterCode = position.letterCode || ''; // Буквенный код
        const displayText = `${position.name} ${letterCode} ${position.lowerBound} - ${upperBoundDisplay} ${position.unit}`;
    
        // Создаем структуру из span элементов для разных частей текста
        const nameSpan = document.createElement('span');
        nameSpan.textContent = displayText;
        option.appendChild(nameSpan);
    
        option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });
    
        // Добавляем класс, если возраст находится в заданном диапазоне
        if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
            option.classList.add('matched-option');
        }
    
        select.appendChild(option);
    
        // Проверяем, соответствует ли текущая опция всем условиям фильтрации
        if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
            selectedOption = option;
        }
    };
    


        
        
        
        
        
        
        
        

        

        // Функция для фильтрации поискового запроса
        const filterOptions = (searchTerm) => {
            const lowerCaseSearch = searchTerm.toLowerCase();
            select.innerHTML = ''; // Очищаем список перед добавлением отфильтрованных элементов

            filteredPositions.forEach(position => {
                // Преобразуем диапазон в строку для поиска
                const rangeString = `${position.lowerBound}-${position.upperBound}`;

                // Проверяем, содержится ли поисковый запрос в названии, единице измерения или диапазоне
                if (position.name.toLowerCase().includes(lowerCaseSearch) ||
                    position.unit.toLowerCase().includes(lowerCaseSearch) ||
                    rangeString.includes(lowerCaseSearch)) {
                    if(tarif !== 'Хромолаб GEN PRO 1.0') {
                    createOption(position);
                    } 
                    
                    if (tarif == 'Хромолаб GEN PRO 1.0') {
                        createOptionGen(position); 
                    }
                }
            });

            // Показываем или скрываем инпут для поиска в зависимости от наличия отфильтрованных элементов
            if (select.options.length > 0) {
                searchInput.style.display = 'block';
            } else {
                searchInput.style.display = 'none';
            }
        };

        // Инициализация инпута для поиска
        searchInput.type = 'text';
        searchInput.placeholder = 'Поиск...';
        searchInput.classList.add('search-input'); // Добавляем класс для стилей
        searchInput.style.display = 'none'; // Начинаем со скрытым инпутом
        searchInput.addEventListener('input', () => {
            filterOptions(searchInput.value.trim());
        });
        container.appendChild(searchInput);

        
        

        // Добавляем выпадающий список в контейнер
        container.appendChild(select);

        // Обработчик клика по выпадающему списку для открытия/закрытия инпута поиска
        select.addEventListener('click', (event) => {
            event.stopPropagation(); // Остановка всплытия события, чтобы клик по select не срабатывал на документе
            isOpen = !isOpen;
            if (isOpen) {
                searchInput.style.display = 'block';
                searchInput.style.backgroundColor = 'white';
                searchInput.style.border = '1px solid #00a2ff8e';
                searchInput.style.boxShadow = 'inset 0 0 15px rgba(156, 156, 156, 0.5)';

                
                
            } else {
                searchInput.style.display = 'none';
            }

           
        });

        // Обработчик для ховера над searchInput
searchInput.addEventListener('mouseenter', () => {
    // Действия при наведении курсора
    searchInput.style.backgroundColor = '#f0f0f0'; // Пример стиля для подсветки при ховере
    searchInput.style.border = '1px solid #00a2ff'; // Пример изменения границы при ховере
});

searchInput.addEventListener('mouseleave', () => {
    // Действия при уходе курсора
    searchInput.style.backgroundColor = 'white'; // Возвращаем исходный цвет при уходе курсора
    searchInput.style.border = '1px solid #dddddd'; // Возвращаем исходную границу при уходе курсора
});

// Обработчик для фокуса на searchInput
searchInput.addEventListener('focus', () => {
    // Действия при фокусе на элементе
    searchInput.style.outline = '1px solid #00a2ff'; // Пример стиля для обводки при фокусе
});

searchInput.addEventListener('blur', () => {
    // Действия при потере фокуса элементом
    searchInput.style.outline = 'none'; // Убираем обводку при потере фокуса
});

        // Добавляем обработчик изменения для обновления стиля
        select.addEventListener('change', () => {
            if (selectedOption && selectedOption.classList.contains('matched-option')) {
                select.classList.add('matched-select');
            } else {
                select.classList.remove('matched-select');
            }
        });


        if(tarif !== 'Хромолаб GEN PRO 1.0') {
            // Инициализируем выпадающий список с текущими фильтрованными данными
        filteredPositions.forEach(createOption);
            }
         if (tarif == 'Хромолаб GEN PRO 1.0') {
                // Инициализируем выпадающий список с текущими фильтрованными данными
        filteredPositions.forEach(createOptionGen);
            }

        

        // Если найдена соответствующая опция при загрузке, делаем её выбранной
        if (selectedOption) {
            selectedOption.selected = true;
        }

        // Обработчик клика на документе для закрытия инпута, если кликнуто вне контейнера
        document.addEventListener('click', (event) => {
            const isClickedInside = container.contains(event.target);
            if (!isClickedInside) {
                isOpen = false;
                searchInput.style.display = 'none';
            }
        });

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}








нет, такая мягкая фильтрация не очень надежная



из дата джейсон пример:

"biochemistry": {
      "group_id": "003",
      "name": "Биохимия",
      "1": "АлАТ",
      "2": "АсАТ",
      "3": "Креатинин",
      "4": "Мочевая кислота",
      "5": "Триглицериды",
      "6": "Холестерин общий (ХС)",
      "7": "Холестерин - ЛПВП (альфа-холестерин)",
      "8": "Холестерин - ЛПНП (бета-холестерин)",
      "9": "Коэффициент атерогенности",
      "10": "C-реактивный белок ультрачувствительный",
      "11": "Железо [свободное,белковосвязанное, сывороточное]",
      "12": "Ферритин",
      "13": "Гликозилированный гемоглобин [HbA1c]"

    },




из нормал позишенс пример:

{
            "id parrent": 10,
            "name": "C-реактивный белок",
            "lowerBound": 0,
            "upperBound": 5,
            "unit": "мг/л",
            "gender": "all",
            "ageLowerBound": 1,
            "ageUpperBound": 120,
            "lab": "Хромолаб",
            "panel": "Хромолаб PRO 1.1"
        },






// Фильтруем данные по названию, полу и панели
        const filteredPositions = data.positions.filter(position => {
            return position.name === filterName && position.panel === tarif &&
                   (position.gender === gender || position.gender === 'all');
        });

        // Сортируем позиции, чтобы сначала шли позиции для текущего пола, затем позиции с "all"
        filteredPositions.sort((a, b) => {
            if (a.gender === gender && b.gender !== gender) {
                return -1;
            } else if (a.gender !== gender && b.gender === gender) {
                return 1;
            } else {
                return 0;
            }
        });

новее:



        // Разбиваем filterName на отдельные слова
        const filterWords = filterName.toLowerCase().split(' ');

        // Фильтруем данные по названию, полу и панели
        const filteredPositions = data.positions.filter(position => {
            const positionNameWords = position.name.toLowerCase().split(' ');

            // Проверяем, содержит ли positionName хотя бы одно слово из filterName
            const nameMatches = filterWords.some(word => positionNameWords.includes(word));

            return nameMatches && position.panel === tarif &&
                   (position.gender === gender || position.gender === 'all');
        });

        // Сортируем позиции, чтобы сначала шли позиции для текущего пола, затем позиции с "all"
        filteredPositions.sort((a, b) => {
            if (a.gender === gender && b.gender !== gender) {
                return -1;
            } else if (a.gender !== gender && b.gender === gender) {
                return 1;
            } else {
                return 0;
            }
        });




надо улучшить функцию ниже, чтобы мы из файла дата получали еще айди каждого отдельного параметра (сам джейсон файл ты не меняй,
я его буду менять сам потом). Полученный айди мы будем назначать как третий аргумент в функцию createHeaderWithCounter
Вот код:



/**
 * Создает контейнер с заголовком, содержащий инпут для умного ввода числовых значений,
 * используя данные из JSON файла.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 */
async function createContainerWithInput(id, type, number, gender, age, parentContainer) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    try {
        // Загружаем данные из JSON файла
        const response = await fetch('data.json');
        const data = await response.json();

        // Определяем заголовок контейнера в зависимости от типа и номера
        let headerText = 'Unknown Type';

        if (data[type] && data[type][number.toString()]) {
            headerText = data[type][number.toString()];
        }

        // Увеличиваем глобальный счетчик контейнеров
        globalContainerCount++;

        // Создаем заголовок с отображаемым значением счетчика
        const headerContainer = createHeaderWithCounter(globalContainerCount, headerText);

        // Добавляем заголовок в контейнер
        container.appendChild(headerContainer);
        container.setAttribute('data-type', type); // Добавляем атрибут для удобства (если нужно)

        // Добавляем контейнер в родительский контейнер
        parentContainer.appendChild(container);

        // Создаем переключатель чекбокса
        await createCheckboxToggle(id, false);

        // Создаем выпадающий список перед инпутом
        await createDropdownList(`${id}-dropdown`, headerText, container, gender, age, tarif);

        // Создаем инпут с помощью функции createSmartInput, передав ID контейнера
        createSmartInput(`${id}-input`, 10, 6, id); // Пример использования createSmartInput с генерацией уникального ID для инпута

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}







        вот пример файла дата:



        {
    "vitamins": {
      "group_id": "001",
      "name": "Витамины",
      "1": "Витамин B1",
      "2": "Витамин B2",
      "3": "Витамин C"
    },
    "minerals": {
      "group_id": "002",
      "name": "Минералы",
      "1": "Литий",
      "2": "Бор",
      "3": "Натрий",
      "4": "Кремний",
      "5": "Калий"
    },
    "biochemistry": {
      "group_id": "003",
      "name": "Биохимия",
      "1": "АлАТ",
      "2": "АсАТ",
      "3": "Креатинин",
      "4": "Мочевая кислота",
      "5": "Триглицериды",
      "6": "Холестерин общий (ХС)",
      "7": "Холестерин - ЛПВП (альфа-холестерин)",
      "8": "Холестерин - ЛПНП (бета-холестерин)",
      "9": "Коэффициент атерогенности",
      "10": "C-реактивный белок ультрачувствительный",
      "id 10": 10,
      "11": "Железо [свободное,белковосвязанное, сывороточное]",
      "12": "Ферритин",
      "13": "Гликозилированный гемоглобин [HbA1c]"

    },

"hematology": {
      "group_id": "004",
      "name": "Гематология",
      "1": "Эритроциты"

    },

    "genetics": {
      "group_id": "005",
      "name": "Генетика",
      "1": "MTHFR (rs 1801133)"

    }
  }







  Хорошо, а вот в коде ниже давай искать параметр не по названию из нормал позишенс, а по
  значению свойства "id parrent" в нормал позишенс у параметра, мы будем искать на странице элемент который будет иметь то же значение. Вот
  функция для улучшения:

/**
 * Создает выпадающий список с элементами, извлечёнными из JSON файла.
 * @param {string} id - ID выпадающего списка.
 * @param {string} filterName - Имя для фильтрации позиций в JSON файле.
 * @param {HTMLElement} container - Контейнер, в который будет добавлен выпадающий список.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {string} tarif - Номер текущей панели.
 * @returns {Promise<void>} - Возвращает промис для синхронизации с другими действиями.
 */
async function createDropdownList(id, filterName, container, gender, age, tarif) {
    let isOpen = false; // Флаг для отслеживания состояния открытия списка
    const select = document.createElement('select');
    const searchInput = document.createElement('input');
    let selectedOption = null; // Выбранная опция

    try {
        select.id = id;
        const response = await fetch('normal_positions.json');
        const data = await response.json();

        // Разбиваем filterName на отдельные слова
        const filterWords = filterName.toLowerCase().split(' ');

        // Фильтруем данные по названию, полу и панели
        const filteredPositions = data.positions.filter(position => {
            const positionNameWords = position.name.toLowerCase().split(' ');

            // Проверяем, содержит ли positionName хотя бы одно слово из filterName
            const nameMatches = filterWords.some(word => positionNameWords.includes(word));

            return nameMatches && position.panel === tarif &&
                   (position.gender === gender || position.gender === 'all');
        });

        // Сортируем позиции, чтобы сначала шли позиции для текущего пола, затем позиции с "all"
        filteredPositions.sort((a, b) => {
            if (a.gender === gender && b.gender !== gender) {
                return -1;
            } else if (a.gender !== gender && b.gender === gender) {
                return 1;
            } else {
                return 0;
            }
        });

        select.addEventListener('change', () => {
            const inputValue = document.getElementById(`${container.id}-input`).value;
            updateGradePanelStatus(inputValue, container.id);

            // Сбрасываем стиль предыдущей выбранной опции
            if (selectedOption) {
                selectedOption.style.color = 'black'; // Черный цвет для не выбранной опции
            }

            // Получаем выбранную опцию
            selectedOption = select.options[select.selectedIndex];
            selectedOption.style.color = 'blue'; // Синий цвет для выбранной опции

            // Получаем значения границ из выбранной опции
            const bounds = JSON.parse(selectedOption.value);
        });

        // Функция для загрузки JSON файла
async function loadGeneticCodes() {
    try {
        const response = await fetch('genetic_codes.json');
        if (!response.ok) {
            throw new Error('Failed to load genetic_codes.json');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error loading genetic_codes.json:', error);
        return null;
    }
}



// Пример функции createOption, которая использует данные из genetic_codes.json
const createOptionGen = async (position) => {
    // Загрузка данных из genetic_codes.json
    const geneticCodes = await loadGeneticCodes();

    if (!geneticCodes) {
        console.error('Failed to load genetic codes data.');
        return;
    }

    const option = document.createElement('option');
    let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте

    // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
    if (position.upperBound === '∞') {
        position.upperBound = 999999;
        upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
    }

    // Функция для замены числовых значений на буквенные коды
    const replaceGeneticCodes = (value) => {
        for (let key in geneticCodes) {
            if (geneticCodes.hasOwnProperty(key)) {
                value = value.replace(new RegExp(geneticCodes[key], 'g'), key);
            }
        }
        return value;
    };

    // Применяем замену на буквенные коды в тексте опции
    const nameSpan = document.createElement('span');
    nameSpan.textContent = `${position.name} ${replaceGeneticCodes(`${position.lowerBound}-${upperBoundDisplay}`)} ${position.unit}`;
    option.appendChild(nameSpan);

    option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });

    // Добавляем класс, если возраст находится в заданном диапазоне
    if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
        option.classList.add('matched-option');
    }

    select.appendChild(option);

    // Проверяем, соответствует ли текущая опция всем условиям фильтрации
    if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
        selectedOption = option;
    }
};







Смотри у нас есть функция для создания контейнера заголовка:



/**
 * Создает заголовок с отображаемым значением счетчика, оборачивая его в дополнительный контейнер с уникальным классом.
 * @param {number} count - Номер контейнера.
 * @param {string} headerText - Текст заголовка.
 * @param {string} paramId - ID параметра.
 * @returns {HTMLElement} - Контейнер с заголовком и счетчиком.
 */
function createHeaderWithCounter(count, headerText, paramId) {
    const headerContainer = document.createElement('div');
    headerContainer.classList.add('headerContainer'); // Добавляем класс для стилей
    headerContainer.id = `header-${paramId}`; // Назначаем ID контейнеру заголовка

    const header = document.createElement('h2');

    // Если длина текста больше 27 символа, обрезаем и добавляем многоточие
    const displayText = headerText.length > 27 ? headerText.slice(0, 27) + '...' : headerText;
    header.textContent = `${count}. ${displayText}`;

    headerContainer.appendChild(header);

    // Флаг для отслеживания состояния расширения контейнера
    let expanded = false;

    // Добавляем обработчик событий для переключения состояния расширения контейнера
    headerContainer.addEventListener('click', () => {
        expanded = !expanded;
        headerContainer.classList.toggle('expanded', expanded);
        
        // Меняем текст при расширении и сжатии контейнера
        if (expanded) {
            header.textContent = `${count}. ${headerText}`;
        } else {
            header.textContent = `${count}. ${displayText}`;
        }
    });

    // Добавляем обработчик события mouseleave для возврата к исходному состоянию
    headerContainer.addEventListener('mouseleave', () => {
        if (expanded) {
                expanded = false;
                headerContainer.classList.remove('expanded');
                header.textContent = `${count}. ${displayText}`;
        }
    });

    return headerContainer;
}



И у нас есть функция для создания выпадающего списка:   

/**
 * Создает выпадающий список с элементами, извлечёнными из JSON файла.
 * @param {string} id - ID выпадающего списка.
 * @param {string} filterName - Имя для фильтрации позиций в JSON файле.
 * @param {HTMLElement} container - Контейнер, в который будет добавлен выпадающий список.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {string} tarif - Номер текущей панели.
 * @returns {Promise<void>} - Возвращает промис для синхронизации с другими действиями.
 */
async function createDropdownList(id, filterName, container, gender, age, tarif) {
    let isOpen = false; // Флаг для отслеживания состояния открытия списка
    const select = document.createElement('select');
    const searchInput = document.createElement('input');
    let selectedOption = null; // Выбранная опция

    try {
        select.id = id;
        const response = await fetch('normal_positions.json');
        const data = await response.json();

        // Разбиваем filterName на отдельные слова
        const filterWords = filterName.toLowerCase().split(' ');

        // Фильтруем данные по названию, полу и панели
        const filteredPositions = data.positions.filter(position => {
            const positionNameWords = position.name.toLowerCase().split(' ');

            // Проверяем, содержит ли positionName хотя бы одно слово из filterName
            const nameMatches = filterWords.some(word => positionNameWords.includes(word));

            return nameMatches && position.panel === tarif &&
                   (position.gender === gender || position.gender === 'all');
        });

        // Сортируем позиции, чтобы сначала шли позиции для текущего пола, затем позиции с "all"
        filteredPositions.sort((a, b) => {
            if (a.gender === gender && b.gender !== gender) {
                return -1;
            } else if (a.gender !== gender && b.gender === gender) {
                return 1;
            } else {
                return 0;
            }
        });

        select.addEventListener('change', () => {
            const inputValue = document.getElementById(`${container.id}-input`).value;
            updateGradePanelStatus(inputValue, container.id);

            // Сбрасываем стиль предыдущей выбранной опции
            if (selectedOption) {
                selectedOption.style.color = 'black'; // Черный цвет для не выбранной опции
            }

            // Получаем выбранную опцию
            selectedOption = select.options[select.selectedIndex];
            selectedOption.style.color = 'blue'; // Синий цвет для выбранной опции

            // Получаем значения границ из выбранной опции
            const bounds = JSON.parse(selectedOption.value);
        });

        // Функция для загрузки JSON файла
async function loadGeneticCodes() {
    try {
        const response = await fetch('genetic_codes.json');
        if (!response.ok) {
            throw new Error('Failed to load genetic_codes.json');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error loading genetic_codes.json:', error);
        return null;
    }
}



// Пример функции createOption, которая использует данные из genetic_codes.json
const createOptionGen = async (position) => {
    // Загрузка данных из genetic_codes.json
    const geneticCodes = await loadGeneticCodes();

    if (!geneticCodes) {
        console.error('Failed to load genetic codes data.');
        return;
    }

    const option = document.createElement('option');
    let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте

    // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
    if (position.upperBound === '∞') {
        position.upperBound = 999999;
        upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
    }

    // Функция для замены числовых значений на буквенные коды
    const replaceGeneticCodes = (value) => {
        for (let key in geneticCodes) {
            if (geneticCodes.hasOwnProperty(key)) {
                value = value.replace(new RegExp(geneticCodes[key], 'g'), key);
            }
        }
        return value;
    };

    // Применяем замену на буквенные коды в тексте опции
    const nameSpan = document.createElement('span');
    nameSpan.textContent = `${position.name} ${replaceGeneticCodes(`${position.lowerBound}-${upperBoundDisplay}`)} ${position.unit}`;
    option.appendChild(nameSpan);

    option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });

    // Добавляем класс, если возраст находится в заданном диапазоне
    if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
        option.classList.add('matched-option');
    }

    select.appendChild(option);

    // Проверяем, соответствует ли текущая опция всем условиям фильтрации
    if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
        selectedOption = option;
    }
};




    const createOption = (position) => {
        const option = document.createElement('option');
        let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте
    
        // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
        if (position.upperBound === '∞') {
            position.upperBound = 999999;
            upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
        }
    
        // Преобразуем числовые границы в буквенные коды для отображения на сайте
        const letterCode = position.letterCode || ''; // Буквенный код
        const displayText = `${position.name} ${letterCode} ${position.lowerBound} - ${upperBoundDisplay} ${position.unit}`;
    
        // Создаем структуру из span элементов для разных частей текста
        const nameSpan = document.createElement('span');
        nameSpan.textContent = displayText;
        option.appendChild(nameSpan);
    
        option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });
    
        // Добавляем класс, если возраст находится в заданном диапазоне
        if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
            option.classList.add('matched-option');
        }
    
        select.appendChild(option);
    
        // Проверяем, соответствует ли текущая опция всем условиям фильтрации
        if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
            selectedOption = option;
        }
    };

    Можно ли сделать так, что айди хедер контейнера получал выпадающий список, т.е. получал его
    значение, а затем из файла нормал позишенс мы бы искали параметры не по названию, как это сейчас,
    а по их свойству "id parrent", сопоставляли значение оттуда со значением айди хэдера, если они совпадают,
    то значит такой параметр добавляем в выпадающий список.





Нужно улучшить функцию. Мы прочитаем джейсон файл panels через feth, он кстати имеет следующую структуру:

{
    "Хромолаб PRO 1.1": {
      "id": 1,
      "options": ["biochemistry", "hematology", "minerals", "insulin resistance"],
      "disable parameters": ["Алюминий Al", "Индекс НОМА"]
    },
    "Хромолаб PRO PLUS 1.0": {
      "id": 2,
      "options": ["biochemistry"]
    },
    "Хромолаб GEN PRO 1.0": {
      "id": 3,
      "options": ["genetics"]
    }
  }


Читать его будем в функциях ниже (но не во всех). 


/**
 * Создает индикатор в виде иконки из Unicode с добавлением класса.
 * @param {boolean} isActive - Значение индикатора. Если true, индикатор будет зеленым (🟢), иначе серым (🔘).
 * @param {HTMLElement} container - HTML элемент, в который будет добавлен индикатор.
 * @returns {void}
 */
function createIndicator(isActive, container) {
    // Определяем символы Unicode для индикаторов
    const grayIcon = '🔘';
    const greenIcon = '🟢';

    // Выбираем иконку в зависимости от значения isActive
    const icon = isActive ? greenIcon : grayIcon;

    // Определяем класс для индикатора
    const indicatorClass = isActive ? 'indicator-green' : 'indicator-gray';

    // Ищем существующий индикатор внутри контейнера
    let indicator = container.querySelector('.indicator');

    if (indicator) {
        // Если индикатор уже существует, обновляем его
        indicator.textContent = icon;
        indicator.className = `indicator ${indicatorClass}`;
    } else {
        // Если индикатора нет, создаем новый и добавляем его в контейнер
        indicator = document.createElement('span');
        indicator.className = `indicator ${indicatorClass}`;
        indicator.textContent = icon;
        container.appendChild(indicator);
    }
}





/**
 * Создает заголовок с отображаемым значением счетчика, оборачивая его в дополнительный контейнер с уникальным классом.
 * @param {number} count - Номер контейнера.
 * @param {string} headerText - Текст заголовка.
 * @param {string} paramId - ID параметра.
 * @returns {HTMLElement} - Контейнер с заголовком и счетчиком.
 */
function createHeaderWithCounter(count, headerText, paramId) {
    const headerContainer = document.createElement('div');
    headerContainer.classList.add('headerContainer'); // Добавляем класс для стилей
    headerContainer.id = `${paramId}`; // Назначаем ID контейнеру заголовка

    const header = document.createElement('h2');

    // Если длина текста больше 27 символа, обрезаем и добавляем многоточие
    const displayText = headerText.length > 27 ? headerText.slice(0, 27) + '...' : headerText;
    header.textContent = `${count}. ${displayText}`;

    headerContainer.appendChild(header);

    // Флаг для отслеживания состояния расширения контейнера
    let expanded = false;

    // Добавляем обработчик событий для переключения состояния расширения контейнера
    headerContainer.addEventListener('click', () => {
        expanded = !expanded;
        headerContainer.classList.toggle('expanded', expanded);

        // Меняем текст при расширении и сжатии контейнера
        if (expanded) {
            header.textContent = `${count}. ${headerText}`;
        } else {
            header.textContent = `${count}. ${displayText}`;
        }
    });

    // Добавляем обработчик события mouseleave для возврата к исходному состоянию
    headerContainer.addEventListener('mouseleave', () => {
        if (expanded) {
            expanded = false;
            headerContainer.classList.remove('expanded');
            header.textContent = `${count}. ${displayText}`;
        }
    });
    return headerContainer;
}


/**
 * Создает контейнер с заголовком, содержащий инпут для умного ввода числовых значений,
 * используя данные из JSON файла.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 */
async function createContainerWithInput(id, type, number, gender, age, parentContainer) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    try {
        // Загружаем данные из JSON файла
        const response = await fetch('data.json');
        const data = await response.json();

        // Определяем заголовок контейнера и ID параметра в зависимости от типа и номера
        let headerText = 'Unknown Type';
        let paramId = null;

        if (data[type]) {
            const groupId = data[type].group_id;
            headerText = data[type][number.toString()] || 'Unknown Parameter';
            paramId = groupId + '-' + number;

            // Проверяем, есть ли соответствующий параметр ID
            const idKey = `id ${number}`;
            if (data[type][idKey]) {
                paramId = data[type][idKey];
            }
        } else {
            console.error(`Data for type "${type}" not found in data.json`);
        }

        // Увеличиваем глобальный счетчик контейнеров
        globalContainerCount++;

        // Создаем заголовок с отображаемым значением счетчика и ID параметра
        const headerContainer = createHeaderWithCounter(globalContainerCount, headerText, paramId);

        // Добавляем заголовок в контейнер
        container.appendChild(headerContainer);
        container.setAttribute('data-type', type); // Добавляем атрибут для удобства (если нужно)

        // Добавляем контейнер в родительский контейнер
        parentContainer.appendChild(container);

        // Создаем переключатель чекбокса
        await createCheckboxToggle(id, false);

        // Создаем выпадающий список перед инпутом
        await createDropdownList(`${id}-dropdown`, headerText, container, gender, age, tarif, paramId);

        // Создаем инпут с помощью функции createSmartInput, передав ID контейнера
        createSmartInput(`${id}-input`, 10, 6, id); // Пример использования createSmartInput с генерацией уникального ID для инпута

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}


Мне нужно, чтобы мы читали запрещенные параметры из джейсон файла, именно на этих
параметрах будет срабатывать переключатель в состояние включено через секунду после
своего создания. Но происходит это разово, чтобы я вручную потом мог его переключить.
Мы будем сопоставлять название хэдер контейнера и имя запрещенного параметра, если они
совпадают, то переключатель автоматически включается, но только разово, чтобы я потом
мог его вручную снова переключать.








ПОмоги с кодом, надо прочитать файл панельс в функции ниже:


/**
 * Создает заголовок с отображаемым значением счетчика, оборачивая его в дополнительный контейнер с уникальным классом.
 * @param {number} count - Номер контейнера.
 * @param {string} headerText - Текст заголовка.
 * @param {string} paramId - ID параметра.
 * @returns {HTMLElement} - Контейнер с заголовком и счетчиком.
 */
function createHeaderWithCounter(count, headerText, paramId) {
    const headerContainer = document.createElement('div');
    headerContainer.classList.add('headerContainer'); // Добавляем класс для стилей
    headerContainer.id = `${paramId}`; // Назначаем ID контейнеру заголовка

    const header = document.createElement('h2');

    // Если длина текста больше 27 символа, обрезаем и добавляем многоточие
    const displayText = headerText.length > 27 ? headerText.slice(0, 27) + '...' : headerText;
    header.textContent = `${count}. ${displayText}`;

    headerContainer.appendChild(header);

    // Загружаем данные из panels.json для проверки запрещенных параметров
    const panelsResponse = await fetch('panels.json');
    const panelsData = await panelsResponse.json();

    // Флаг для отслеживания состояния расширения контейнера
    let expanded = false;

    // Добавляем обработчик событий для переключения состояния расширения контейнера
    headerContainer.addEventListener('click', () => {
        expanded = !expanded;
        headerContainer.classList.toggle('expanded', expanded);

        // Меняем текст при расширении и сжатии контейнера
        if (expanded) {
            header.textContent = `${count}. ${headerText}`;
        } else {
            header.textContent = `${count}. ${displayText}`;
        }
    });

    // Добавляем обработчик события mouseleave для возврата к исходному состоянию
    headerContainer.addEventListener('mouseleave', () => {
        if (expanded) {
            expanded = false;
            headerContainer.classList.remove('expanded');
            header.textContent = `${count}. ${displayText}`;
        }
    });
    return headerContainer;
}


Вот кстати структура файла panels.json:

{
    "Хромолаб PRO 1.1": {
      "id": 1,
      "options": ["biochemistry", "hematology", "minerals", "insulin resistance"],
      "disable parameters": ["Алюминий Al", "Индекс НОМА"]
    },
    "Хромолаб PRO PLUS 1.0": {
      "id": 2,
      "options": ["biochemistry"]
    },
    "Хромолаб GEN PRO 1.0": {
      "id": 3,
      "options": ["genetics"]
    }
  }

  мы будем читать оттуда главное название, сравнивать его со значением глобальной переменной tarif, при полном
  совпадении мы выбираем определенный блок из этого файла, затем в его свойствах disable parameters перебираем
  значения, если какое либо из них совпадает с headerText из функции, то вызываем переключение счетчика внутри функции.
  Вот кстати код счетчика:


/**
 * Асинхронно создает переключатель чекбокса.
 * @param {string} id - Идентификатор элемента, куда будет вставлен чекбокс.
 * @param {boolean} defaultValue - Значение по умолчанию (true - включен, false - выключен).
 */
async function createCheckboxToggle(id, defaultValue) {
    try {
        // Находим элемент, куда нужно вставить переключатель
        const container = document.getElementById(id);
        
        // Создаем элементы чекбокса
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = defaultValue;
        
        // Добавляем информацию о чекбоксе в массив checkboxStates
        checkboxStates.push({ id, checked: defaultValue });

        // Добавляем классы для стилизации (будут определены в CSS)
        checkbox.classList.add('toggle-checkbox');
        
        // Устанавливаем стиль для смещения чекбокса на 550 пикселей влево
        checkbox.style.position = 'absolute';
        checkbox.style.left = '300px';
        checkbox.style.border = '1px solid rgba(78, 78, 78, 0.25)';
        checkbox.style.borderRadius = '20px';
        
        // Добавляем обработчик события изменения состояния чекбокса
        checkbox.addEventListener('change', function() {
            const dropdownId = `${id}-dropdown`;
            const inputId = `${id}-input`;
            const dropdown = document.getElementById(dropdownId);
            const input = document.getElementById(inputId);
        
            if (checkbox.checked) {
                // Блокируем выпадающий список и инпут
                if (dropdown) {
                    dropdown.disabled = true;
                    // Очищаем значение выпадающего списка
                    dropdown.selectedIndex = -1;
                }
                if (input) {
                    input.disabled = true;
                    // Очищаем значение инпута
                    input.value = '';
                    updateGradePanelStatus(input.value, container.id, checkbox.checked); // Передача состояния чекбокса
                }
                // Показываем индикатор
                createIndicator(true, container);
            } else {
                // Разблокируем выпадающий список и инпут
                if (dropdown) dropdown.disabled = false;
                if (input) input.disabled = false;
                // Скрываем индикатор
                createIndicator(false, container);
            }
        
            // Обновляем значение в массиве checkboxStates
            const index = checkboxStates.findIndex(item => item.id === id);
            if (index !== -1) {
                checkboxStates[index].checked = checkbox.checked;
            }
            console.log(`Checkbox ${id} changed: ${checkbox.checked}`);
        });
        
        
        
        // Добавляем чекбокс в контейнер
        container.appendChild(checkbox);
    } catch (error) {
        console.error('Error creating checkbox:', error);
    }
}



















Смотри, у нас ниже есть функция (ее нужно будет улучшить):


/**
 * Создает контейнер с заголовком, содержащий чекбокс, выпадающий список и инпут.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 * @param {Object} panels - Данные из panels.json для проверки запрещенных параметров.
 */
async function createContainerWithInput(id, type, number, gender, age, parentContainer, panels) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    try {
        // Загружаем данные из JSON файла
        const response = await fetch('data.json');
        const data = await response.json();

        // Определяем заголовок контейнера и ID параметра в зависимости от типа и номера
        let headerText = 'Unknown Type';
        let paramId = null;

        if (data[type]) {
            const groupId = data[type].group_id;
            headerText = data[type][number.toString()] || 'Unknown Parameter';
            paramId = groupId + '-' + number;

            // Проверяем, есть ли соответствующий параметр ID
            const idKey = `id ${number}`;
            if (data[type][idKey]) {
                paramId = data[type][idKey];
            }
        } else {
            console.error(`Data for type "${type}" not found in data.json`);
        }

        // Увеличиваем глобальный счетчик контейнеров
        globalContainerCount++;

        // Создаем заголовок с отображаемым значением счетчика и ID параметра
        const headerContainer = createHeaderWithCounter(globalContainerCount, headerText, paramId);

        // Добавляем заголовок в контейнер
        container.appendChild(headerContainer);
        container.setAttribute('data-type', type); // Добавляем атрибут для удобства (если нужно)

        // Добавляем контейнер в родительский контейнер
        parentContainer.appendChild(container);

        // Создаем переключатель чекбокса с использованием данных из panels.json
        await createCheckboxToggle(id, false, panels);

        // Создаем выпадающий список перед инпутом
        await createDropdownList(`${id}-dropdown`, headerText, container, gender, age, tarif, paramId);

        // Создаем инпут с помощью функции createSmartInput, передав ID контейнера
        createSmartInput(`${id}-input`, 10, 6, id); // Пример использования createSmartInput с генерацией уникального ID для инпута

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}


Мне нужно, чтобы без ущерба чтения data.json и связанной с этим логики - мы дополнительно читали тем же методом
файл panels.json, у него кстати следующая структура (ее менять не надо):


{
    "Хромолаб PRO 1.1": {
      "id": 1,
      "options": ["vitamins", "biochemistry", "hematology", "minerals", "insulin resistance"],
      "disable parameters": ["Алюминий Al", "Индекс НОМА"]
    },
    "Хромолаб PRO PLUS 1.0": {
      "id": 2,
      "options": ["biochemistry"]
    },
    "Хромолаб GEN PRO 1.0": {
      "id": 3,
      "options": ["genetics"]
    }
  }

  Так вот, а еще мы проверяем значение глобальной переменной tarif (она уже объявлена в другой части проекта),
  если значение глобальной переменной совпадает с именем блока в panels.json, например "Хромолаб PRO PLUS 1.0", то
  мы проверяем именно этот блок, а конкретнее свойство в нем disable parameters (проходимся по массиву по каждому элементу),
  если значение из массива совпадает с переменнной headerText, то в таком случае при создании createCheckboxToggle мы
  передаем не false а true



Посмотри код ниже:

/**
 * Создает контейнер с заголовком, содержащий чекбокс, выпадающий список и инпут.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 * @param {Object} panels - Данные из panels.json для проверки запрещенных параметров.
 */
async function createContainerWithInput(id, type, number, gender, age, parentContainer, panels) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    try {
        // Загружаем данные из JSON файла
        const response = await fetch('data.json');
        const data = await response.json();

        // Определяем заголовок контейнера и ID параметра в зависимости от типа и номера
        let headerText = 'Unknown Type';
        let paramId = null;

        if (data[type]) {
            const groupId = data[type].group_id;
            headerText = data[type][number.toString()] || 'Unknown Parameter';
            paramId = groupId + '-' + number;

            // Проверяем, есть ли соответствующий параметр ID
            const idKey = `id ${number}`;
            if (data[type][idKey]) {
                paramId = data[type][idKey];
            }
        } else {
            console.error(`Data for type "${type}" not found in data.json`);
        }

        // Увеличиваем глобальный счетчик контейнеров
        globalContainerCount++;

        // Создаем заголовок с отображаемым значением счетчика и ID параметра
        const headerContainer = createHeaderWithCounter(globalContainerCount, headerText, paramId);

        // Добавляем заголовок в контейнер
        container.appendChild(headerContainer);
        container.setAttribute('data-type', type); // Добавляем атрибут для удобства (если нужно)

        // Добавляем контейнер в родительский контейнер
        parentContainer.appendChild(container);

        // Загружаем данные из panels.json
        const panelsResponse = await fetch('panels.json');
        const panelsData = await panelsResponse.json();

        // Определяем нужно ли отключить параметр в зависимости от значения переменной tarif
        let disableToggle = false;
        if (panelsData[tarif] && panelsData[tarif]['disable parameters']) {
            disableToggle = panelsData[tarif]['disable parameters'].includes(headerText);
        }

        // Создаем переключатель чекбокса с использованием данных из panels.json
        await createCheckboxToggle(id, disableToggle, panels);

        // Создаем выпадающий список перед инпутом
        await createDropdownList(`${id}-dropdown`, headerText, container, gender, age, tarif, paramId, disableToggle);

        // Создаем инпут с помощью функции createSmartInput, передавая значение disableToggle
        createSmartInput(`${id}-input`, 10, 6, id, disableToggle);

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}

/**
 * Главная функция, загружающая данные и создающая контейнеры последовательно.
 * @param {HTMLElement} parentContainer - Контейнер, в который будут добавлены новые контейнеры.
 * @param {Array} containerConfigs - Массив конфигураций для контейнеров.
 */
async function initializeContainers(parentContainer, containerConfigs) {
    try {
        // Загружаем данные из JSON файла
        const response = await fetch('data.json');
        const data = await response.json();
        
        // Загружаем данные из panels.json
        const panelsResponse = await fetch('panels.json');
        const panelsData = await panelsResponse.json();

        // Создаем контейнеры последовательно
        for (const config of containerConfigs) {
            const { id, type, number, gender, age } = config;
            await createContainerWithInput(id, type, number, gender, age, parentContainer, panelsData);
        }
    } catch (error) {
        console.error('Error initializing containers:', error);
    }
}


а вот структура data.json (ее менять не надо):

{
    "vitamins": {
      "group_id": "001",
      "name": "Витамины",
      "1": "Витамин D",
      "id 1": "Витамин D",
      "2": "Витамин E",
      "id 2": "Витамин E",
      "3": "Витамин B9",
      "id 3": "Витамин B9",
      "4": "Витамин В12",
      "id 4": "Витамин В12"
    },
    "minerals": {
      "group_id": "002",
      "name": "Минералы",
      "1": "Литий Li",
      "id 1": "Литий Li",
      "2": "Бор Bo",
      "id 2": "Бор Bo",
      "3": "Натрий Na",
      "id 3": "Натрий Na",
      "4": "Кремний Si",
      "id 4": "Кремний Si",
      "5": "Калий K",
      "id 5": "Калий K",
      "6": "Кальций Ca",
      "id 6": "Кальций Ca",
      "7": "Хром Cr",
      "id 7": "Хром Cr",
      "8": "Кадмий Cd",
      "id 8": "Кадмий Cd",
      "9": "Свинец Pb",
      "id 9": "Свинец Pb",
      "10": "Магний Mg",
      "id 10": "Магний Mg",
      "12": "Титан Ti",
      "id 12": "Титан Ti",
      "13": "Марганец Mn",
      "id 13": "Марганец Mn",
      "14": "Железо Fe",
      "id 14": "Железо Fe",
      "15": "Кобальт Co",
      "id 15": "Кобальт Co",
      "16": "Никель Ni",
      "id 16": "Никель Ni",
      "17": "Медь Cu",
      "id 17": "Медь Cu",
      "18": "Цинк Zn",
      "id 18": "Цинк Zn",
      "19": "Мышьяк As",
      "id 19": "Мышьяк As",
      "20": "Селен Se",
      "id 20": "Селен Se",
      "21": "Молибден Mo",
      "id 21": "Молибден Mo",
      "22": "Сурьма Sb",
      "id 22": "Сурьма Sb",
      "23": "Ртуть Hg",
      "id 23": "Ртуть Hg"

      
    },
    "biochemistry": {
      "group_id": "003",
      "name": "Биохимия",
      "1": "АлАТ",
      "id 1": "АлАТ",
      "2": "АсАТ",
      "id 2": "АсАТ",
      "3": "Креатинин",
      "id 3": "Креатинин",
      "4": "Мочевая кислота",
      "id 4": "Мочевая кислота",
      "5": "Триглицериды",
      "id 5": "Триглицериды",
      "6": "Холестерин общий",
      "id 6": "Холестерин общий",
      "7": "Холестерин - ЛПВП",
      "id 7": "Холестерин - ЛПВП",
      "8": "Холестерин - ЛПНП",
      "id 8": "Холестерин - ЛПНП",
      "9": "Коэффициент атерогенности",
      "id 9": "Коэффициент атерогенности",
      "10": "C-реактивный белок",
      "id 10": "C-реактивный белок",
      "11": "Железо [свободное,белковосвязанное, сывороточное]",
      "id 11": "Железо [свободное,белковосвязанное, сывороточное]",
      "12": "Ферритин",
      "id 12": "Ферритин",
      "13": "Гликозилированный гемоглобин [HbA1c]",
      "id 13": "Гликозилированный гемоглобин [HbA1c]",
      "14": "Гомоцистеин",
      "id 14": "Гомоцистеин"

    },

"hematology": {
      "group_id": "004",
      "name": "Гематология",
      "1": "Эритроциты",
      "id 1": "Эритроциты",
      "2": "Гемоглобин",
      "id 2": "Гемоглобин",
      "3": "Гематокрит",
      "id 3": "Гематокрит",
      "4": "Тромбоциты",
      "id 4": "Тромбоциты",
      "5": "Лейкоциты",
      "id 5": "Лейкоциты",
      "6": "Нейтрофилы",
      "id 6": "Нейтрофилы"

    },

    "insulin resistance": {
      "group_id": "005",
      "name": "Инсулинорезистентность",
      "1": "Глюкоза",
      "id 1": "Глюкоза",
      "2": "Инсулин",
      "id 2": "Инсулин",
      "3": "Индекс НОМА",
      "id 3": "Индекс НОМА",
      "4": "Индекс CARO",
      "id 4": "Индекс CARO"

    },

    "genetics": {
      "group_id": "006",
      "name": "Генетика",
      "1": "MTHFR [rs 1801133]",
      "id 1": "MTHFR [rs 1801133]"

    }
  }

  Мне нужно что в хэдер текст номера параметров(не айди) создавались в строгом порядке,
  сейчас они иногда создаются иногда нет.





Смотри, у нас есть переменная parallelDataBuffer со следующей структурой:


  let parallelDataBuffer = [
{ parameterHeader: "", lowerBound: "", upperBound: "", inputValue: "" },

// и так далее.
];


У и нас есть функция createContainerWithInput:


/**
 * Создает контейнер с заголовком, содержащий чекбокс, выпадающий список и инпут.
 * @param {string} id - ID контейнера.
 * @param {string} type - Тип параметра ('vitamins', 'minerals', 'biochemistry').
 * @param {number} number - Номер параметра в списке типа.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {HTMLElement} parentContainer - Контейнер, в который будет добавлен новый контейнер.
 * @param {Object} panels - Данные из panels.json для проверки запрещенных параметров.
 */
async function createContainerWithInput(id, type, number, gender, age, parentContainer, panels) {
    const container = document.createElement('div');
    container.id = id;
    container.classList.add('inputContainer'); // Добавляем класс для стилей (если нужно)

    try {
        // Загружаем данные из JSON файла
        const response = await fetch('data.json');
        const data = await response.json();

        // Определяем заголовок контейнера и ID параметра в зависимости от типа и номера
        let headerText = 'Unknown Parameter';
        let paramId = null;

        if (data[type]) {
            const groupId = data[type].group_id;
            paramId = groupId + '-' + number;

            // Проверяем, есть ли соответствующий параметр ID
            const idKey = `id ${number}`;
            if (data[type][idKey]) {
                headerText = data[type][idKey];
                paramId = data[type][idKey];
            } else if (data[type][number.toString()]) {
                headerText = data[type][number.toString()];
            }
        } else {
            console.error(`Data for type "${type}" not found in data.json`);
        }

        // Увеличиваем глобальный счетчик контейнеров
        globalContainerCount++;

        // Создаем заголовок с отображаемым значением счетчика и ID параметра
        const headerContainer = createHeaderWithCounter(globalContainerCount, headerText, paramId);

        // Добавляем заголовок в контейнер
        container.appendChild(headerContainer);
        container.setAttribute('data-type', type); // Добавляем атрибут для удобства (если нужно)

        // Добавляем контейнер в родительский контейнер
        parentContainer.appendChild(container);

        // Загружаем данные из panels.json
        const panelsResponse = await fetch('panels.json');
        const panelsData = await panelsResponse.json();

        // Определяем нужно ли отключить параметр в зависимости от значения переменной tarif
        let disableToggle = false;
        if (panelsData[tarif] && panelsData[tarif]['disable parameters']) {
            disableToggle = panelsData[tarif]['disable parameters'].includes(headerText);
        }

        // Создаем переключатель чекбокса с использованием данных из panels.json
        await createCheckboxToggle(id, disableToggle, panels);

        // Создаем выпадающий список перед инпутом
        await createDropdownList(`${id}-dropdown`, headerText, container, gender, age, tarif, paramId, disableToggle);

        // Создаем инпут с помощью функции createSmartInput, передавая значение disableToggle
        createSmartInput(`${id}-input`, 10, 6, id, disableToggle);

    } catch (error) {
        console.error('Error fetching data:', error);
    }
}


Можно ли сделать так, чтобы значение из headerText автоматически помещалось в parallelDataBuffer, а конкретнее
в parameterHeader в нем, при создании createContainerWithInput, и чтобы потом мы могли проверить parallelDataBuffer
через консоль как он заполнен.









/**
 * Создает выпадающий список с элементами, извлечёнными из JSON файла.
 * @param {string} id - ID выпадающего списка.
 * @param {string} filterName - Имя для фильтрации позиций в JSON файле.
 * @param {HTMLElement} container - Контейнер, в который будет добавлен выпадающий список.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {string} tarif - Номер текущей панели.
 * @param {boolean} disableToggleOnCreation - Указывает, должен ли список быть заблокирован при создании.
 * @returns {Promise<void>} - Возвращает промис для синхронизации с другими действиями.
 */
async function createDropdownList(id, filterName, container, gender, age, tarif, paramId, disableToggleOnCreation) {
    let isOpen = false; // Флаг для отслеживания состояния открытия списка
    const select = document.createElement('select');
    const searchInput = document.createElement('input');
    let selectedOption = null; // Выбранная опция
    let sistertHeader = paramId; // Получаем айди сестринского хэдер контейнера

    // Если disableToggleOnCreation истинно, блокируем выпадающий список сразу
    if (disableToggleOnCreation) {
        select.disabled = true; // Устанавливаем disabled для блокировки select
    } else {
        select.disabled = false;
 
    }

    try {
        select.id = id;
        const response = await fetch('normal_positions.json');
        const data = await response.json();

        // Функция для проверки совпадения имени позиции по первым трем словам или полностью
        const nameMatches = (positionName, filterName) => {
            const positionNameWords = positionName.toLowerCase().split(' ');
            const filterNameWords = filterName.toLowerCase().split(' ');


            

            // Проверяем, содержит ли positionName хотя бы первые три слова из filterName
            if (filterNameWords.length >= 3) {
                const firstThreeFilterWords = filterNameWords.slice(0, 3);
                const firstThreePositionWords = positionNameWords.slice(0, 3);
                if (firstThreeFilterWords.every(word => firstThreePositionWords.includes(word))) {
                    return true;
                }
            }

            // Проверяем, содержит ли positionName все слова из filterName
            if (positionNameWords.length >= filterNameWords.length) {
                if (filterNameWords.every(word => positionNameWords.includes(word))) {
                    return true;
                }
            }
            
            return false;
        };

        // Фильтруем данные по имени, полу и панели
const filteredPositions = data.positions.filter(position => {
    return nameMatches(position.name, filterName) && 
           position.panel.toLowerCase().startsWith(tarif.toLowerCase().split(' ')[0]) && 
           (position.gender === gender || position.gender === 'all'); 
});


        // Сортируем позиции, чтобы сначала шли позиции для текущего пола, затем "all", затем по возрасту
        filteredPositions.sort((a, b) => {
            if (a.current && !b.current) {
                return -1;
            } else if (!a.current && b.current) {
                return 1;
            } else {
                // Сравниваем пол
                if (a.gender === gender && b.gender !== gender) {
                    return -1;
                } else if (a.gender !== gender && b.gender === gender) {
                    return 1;
                } else {
                    // При равенстве по полу, сортируем по "all", затем по возрасту
                    if (a.gender === 'all' && b.gender !== 'all') {
                        return -1;
                    } else if (a.gender !== 'all' && b.gender === 'all') {
                        return 1;
                    } else {
                        // При равенстве по полу и "all", сортируем по возрасту
                        return a.ageLowerBound - b.ageLowerBound;
                    }
                }
            }
        });
        


        

        

        select.addEventListener('change', () => {
            const inputValue = document.getElementById(`${container.id}-input`).value;
            updateGradePanelStatus(inputValue, container.id);
            

            // Сбрасываем стиль предыдущей выбранной опции
            if (selectedOption) {
                selectedOption.style.color = 'black'; // Черный цвет для не выбранной опции
            }

            // Получаем выбранную опцию
            selectedOption = select.options[select.selectedIndex];
            selectedOption.style.color = 'blue'; // Синий цвет для выбранной опции

            // Получаем значения границ из выбранной опции
            const bounds = JSON.parse(selectedOption.value);
        });

        // Функция для загрузки JSON файла
async function loadGeneticCodes() {
    try {
        const response = await fetch('genetic_codes.json');
        if (!response.ok) {
            throw new Error('Failed to load genetic_codes.json');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error loading genetic_codes.json:', error);
        return null;
    }
}



// Пример функции createOption, которая использует данные из genetic_codes.json
const createOptionGen = async (position) => {
    // Загрузка данных из genetic_codes.json
    const geneticCodes = await loadGeneticCodes();

    if (!geneticCodes) {
        console.error('Failed to load genetic codes data.');
        return;
    }

    const option = document.createElement('option');
    let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте

    // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
    if (position.upperBound === '∞') {
        position.upperBound = 999999;
        upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
    }

    // Функция для замены числовых значений на буквенные коды
    const replaceGeneticCodes = (value) => {
        for (let key in geneticCodes) {
            if (geneticCodes.hasOwnProperty(key)) {
                value = value.replace(new RegExp(geneticCodes[key], 'g'), key);
            }
        }
        return value;
    };

    // Применяем замену на буквенные коды в тексте опции
    const nameSpan = document.createElement('span');
    nameSpan.textContent = `${position.name} ${replaceGeneticCodes(`${position.lowerBound}-${upperBoundDisplay}`)} ${position.unit}`;
    option.appendChild(nameSpan);

    option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });

    // Добавляем класс, если возраст находится в заданном диапазоне
    if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
        option.classList.add('matched-option');
    }

    select.appendChild(option);

    // Проверяем, соответствует ли текущая опция всем условиям фильтрации
    if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
        selectedOption = option;
    }
};







let parallelDataBuffer = [
    { parameterHeader: "", lowerBound: "", upperBound: "", inputValue: "" }
];


Можем ли мы так же здесь добавить вставку текущих значений lowerBound и upperBound из этой функции в parallelDataBuffer,
а именно второго и третьего свойства: lowerBound и upperBound, когда те выставились либо вручную пользователем (что приоритетнее),
либо автоматически системой через условия фильтрации (но фильтрация не должна запускаться, если в parallelDataBuffer эти свойства
 уже имеют значения). В обоих случаях мы будем сопоставлять значения из filterName
функции со значением parameterHeader и parallelDataBuffer, чтобы при совпадении на этой же строке массива менять параметры
lowerBound и upperBound по умолчанию на те, что из parallelDataBuffer
Вот код:


/**
 * Создает выпадающий список с элементами, извлечёнными из JSON файла.
 * @param {string} id - ID выпадающего списка.
 * @param {string} filterName - Имя для фильтрации позиций в JSON файле.
 * @param {HTMLElement} container - Контейнер, в который будет добавлен выпадающий список.
 * @param {string} gender - Пол (например, 'male', 'female').
 * @param {number} age - Возраст.
 * @param {string} tarif - Номер текущей панели.
 * @param {boolean} disableToggleOnCreation - Указывает, должен ли список быть заблокирован при создании.
 * @returns {Promise<void>} - Возвращает промис для синхронизации с другими действиями.
 */
async function createDropdownList(id, filterName, container, gender, age, tarif, paramId, disableToggleOnCreation) {
    let isOpen = false; // Флаг для отслеживания состояния открытия списка
    const select = document.createElement('select');
    const searchInput = document.createElement('input');
    let selectedOption = null; // Выбранная опция
    let sistertHeader = paramId; // Получаем айди сестринского хэдер контейнера

    // Если disableToggleOnCreation истинно, блокируем выпадающий список сразу
    if (disableToggleOnCreation) {
        select.disabled = true; // Устанавливаем disabled для блокировки select
    } else {
        select.disabled = false;
 
    }

    try {
        select.id = id;
        const response = await fetch('normal_positions.json');
        const data = await response.json();

        // Функция для проверки совпадения имени позиции по первым трем словам или полностью
        const nameMatches = (positionName, filterName) => {
            const positionNameWords = positionName.toLowerCase().split(' ');
            const filterNameWords = filterName.toLowerCase().split(' ');


            

            // Проверяем, содержит ли positionName хотя бы первые три слова из filterName
            if (filterNameWords.length >= 3) {
                const firstThreeFilterWords = filterNameWords.slice(0, 3);
                const firstThreePositionWords = positionNameWords.slice(0, 3);
                if (firstThreeFilterWords.every(word => firstThreePositionWords.includes(word))) {
                    return true;
                }
            }

            // Проверяем, содержит ли positionName все слова из filterName
            if (positionNameWords.length >= filterNameWords.length) {
                if (filterNameWords.every(word => positionNameWords.includes(word))) {
                    return true;
                }
            }
            
            return false;
        };

        // Фильтруем данные по имени, полу и панели
const filteredPositions = data.positions.filter(position => {
    return nameMatches(position.name, filterName) && 
           position.panel.toLowerCase().startsWith(tarif.toLowerCase().split(' ')[0]) && 
           (position.gender === gender || position.gender === 'all'); 
});


        // Сортируем позиции, чтобы сначала шли позиции для текущего пола, затем "all", затем по возрасту
        filteredPositions.sort((a, b) => {
            if (a.current && !b.current) {
                return -1;
            } else if (!a.current && b.current) {
                return 1;
            } else {
                // Сравниваем пол
                if (a.gender === gender && b.gender !== gender) {
                    return -1;
                } else if (a.gender !== gender && b.gender === gender) {
                    return 1;
                } else {
                    // При равенстве по полу, сортируем по "all", затем по возрасту
                    if (a.gender === 'all' && b.gender !== 'all') {
                        return -1;
                    } else if (a.gender !== 'all' && b.gender === 'all') {
                        return 1;
                    } else {
                        // При равенстве по полу и "all", сортируем по возрасту
                        return a.ageLowerBound - b.ageLowerBound;
                    }
                }
            }
        });
        


        

        

        select.addEventListener('change', () => {
            const inputValue = document.getElementById(`${container.id}-input`).value;
            updateGradePanelStatus(inputValue, container.id);
            

            // Сбрасываем стиль предыдущей выбранной опции
            if (selectedOption) {
                selectedOption.style.color = 'black'; // Черный цвет для не выбранной опции
            }

            // Получаем выбранную опцию
            selectedOption = select.options[select.selectedIndex];
            selectedOption.style.color = 'blue'; // Синий цвет для выбранной опции

            // Получаем значения границ из выбранной опции
            const bounds = JSON.parse(selectedOption.value);
        });

        // Функция для загрузки JSON файла
async function loadGeneticCodes() {
    try {
        const response = await fetch('genetic_codes.json');
        if (!response.ok) {
            throw new Error('Failed to load genetic_codes.json');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error loading genetic_codes.json:', error);
        return null;
    }
}



// Пример функции createOption, которая использует данные из genetic_codes.json
const createOptionGen = async (position) => {
    // Загрузка данных из genetic_codes.json
    const geneticCodes = await loadGeneticCodes();

    if (!geneticCodes) {
        console.error('Failed to load genetic codes data.');
        return;
    }

    const option = document.createElement('option');
    let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте

    // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
    if (position.upperBound === '∞') {
        position.upperBound = 999999;
        upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
    }

    // Функция для замены числовых значений на буквенные коды
    const replaceGeneticCodes = (value) => {
        for (let key in geneticCodes) {
            if (geneticCodes.hasOwnProperty(key)) {
                value = value.replace(new RegExp(geneticCodes[key], 'g'), key);
            }
        }
        return value;
    };

    // Применяем замену на буквенные коды в тексте опции
    const nameSpan = document.createElement('span');
    nameSpan.textContent = `${position.name} ${replaceGeneticCodes(`${position.lowerBound}-${upperBoundDisplay}`)} ${position.unit}`;
    option.appendChild(nameSpan);

    option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });

    // Добавляем класс, если возраст находится в заданном диапазоне
    if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
        option.classList.add('matched-option');
    }

    select.appendChild(option);

    // Проверяем, соответствует ли текущая опция всем условиям фильтрации
    if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
        selectedOption = option;
    }
};




    const createOption = (position) => {
        const option = document.createElement('option');
        let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте
    
        // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
        if (position.upperBound === '∞') {
            position.upperBound = 999999;
            upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
        }
    
        // Преобразуем числовые границы в буквенные коды для отображения на сайте
        const letterCode = position.letterCode || ''; // Буквенный код
        const displayText = `${position.name} ${letterCode} ${position.lowerBound} - ${upperBoundDisplay} ${position.unit}`;
    
        // Создаем структуру из span элементов для разных частей текста
        const nameSpan = document.createElement('span');
        nameSpan.textContent = displayText;
        option.appendChild(nameSpan);
    
        option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });
    
        // Добавляем класс, если возраст находится в заданном диапазоне
        if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
            option.classList.add('matched-option');
        }
    
        select.appendChild(option);
    
        // Проверяем, соответствует ли текущая опция всем условиям фильтрации
        if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
            selectedOption = option;
        }
    };



    const createOption = (position) => {
        const option = document.createElement('option');
        let upperBoundDisplay = position.upperBound; // Значение, которое будет отображаться на сайте
    
        // Если верхняя граница "∞", заменяем на 999999 для обработки в JavaScript
        if (position.upperBound === '∞') {
            position.upperBound = 999999;
            upperBoundDisplay = '∞'; // Отображаем символ бесконечности на сайте
        }
    
        // Преобразуем числовые границы в буквенные коды для отображения на сайте
        const letterCode = position.letterCode || ''; // Буквенный код
        const displayText = `${position.name} ${letterCode} ${position.lowerBound} - ${upperBoundDisplay} ${position.unit}`;
    
        // Создаем структуру из span элементов для разных частей текста
        const nameSpan = document.createElement('span');
        nameSpan.textContent = displayText;
        option.appendChild(nameSpan);
    
        option.value = JSON.stringify({ lowerBound: position.lowerBound, upperBound: position.upperBound });
    
        // Добавляем класс, если возраст находится в заданном диапазоне
        if (age >= position.ageLowerBound && age <= position.ageUpperBound) {
            option.classList.add('matched-option');
        }
    
        select.appendChild(option);
    
        // Проверяем, соответствует ли текущая опция всем условиям фильтрации
        if (!selectedOption && age >= position.ageLowerBound && age <= position.ageUpperBound) {
            selectedOption = option;
        }
    };



    Хорошо, у нас глобально в другой части проекта есть такая переменная с такой структурой


    let parallelDataBuffer = [
    { parameterHeader: "", lowerBound: "", upperBound: "", inputValue: "" }
];


давай ее прочитает в этом участке кода, который ты показал, сопоставим значения из нее сперва
между filterName и parameterHeader, если они совпадают, то берем с той же строки массива значения из
lowerBound, upperBound, сравниваем их со значениями, которые уже выставились по тем же нижним и верхним
границам норм но уже в этой функции, если они не совпадают, то меняем значения из нашей функции на 
значения из parallelDataBuffer.